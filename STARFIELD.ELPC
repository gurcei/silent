#output "starfield"

' BANK4 Memory usage
' ------------------
' 4.0000 DMA-LIST
' 4.0020 var interface to assembly
'        0020: ptr to default_red&
'        0022: ptr to default_green&
'        0024: ptr to default_blue&
'        0026: ptr to curr_red&
'        0028: ptr to curr_green&
'        002a: ptr to curr_blue&
'        002c: ptr to data_addr%
'        002e: ptr to cdata_addr%
'        0030: ptr to scraddr%
'        0032: ptr to clraddr%
'        0034: ptr to inc%
'        0036: ptr to starx%
'        0038: ptr to starvx%
' 4.0800 SCREEN MEMORY
' 4.2000 PETSCII GRAPHICS for BAS logo

' BANK5 Memory usage
' ------------------
' 5.0000 screen buffer for draw_petscii_frame
' 5.1000 color ram buffer for draw_petscii_frame
' 5.2000 screen buffer2 for line-drawing layer


'--------
.declares
'--------
#declare starx%(20), stary(20), starvx%(20)
#declare k

#declare fname$, val&
#declare ldata&(12288), didx%=0, pidx%=0
#declare group_flag&, val&, rev_flag& = 0
#declare offs, ver=2
#declare lastflag, last_group_idx
#declare oldx, oldy, oldoffs, x, y, a$, xx, yy, debug, z$

#declare chr

#declare src_addr, dest_addr, length, transp

#declare loc, ptr, m, tstart


'-------
.defines
'-------
#define OP_COPY = 0
#define OP_MIX  = 1
#define OP_SWAP = 2
#define OP_FILL = 3

#define DST_DEC = 32
#define SRC_DEC = 16


'----
.main
'----
  gosub init

.main_loop
  tstart = ti
  m = m + 1
  gosub draw_starfield
  if m >= 70 and m < 800 then gosub play_data_iter  ' line data
  gosub page_flip

  gosub iter_starfield
  ' cursor 0,0:print m

  if m > 850 and m < 950 then gosub scroll_canvas_right

  if m = 950 then poke $d020,2

  do while (ti-tstart < .03)
  loop

  goto main_loop
  end


'----
.init
'----
  m = 0

  bank 0:bload "asmhelper":bank 128

  ' switch back to upper-case
  poke $d018, peek($d018) and $fd

  print chr$(27);"5";

  for k = 0 to 20
    starx%(k) = int(rnd(1)*80)*256
    stary(k) = int(rnd(1)*50)
    starvx%(k) = (rnd(1)*4 + .5)*256
  next k

  ' clear the offscreen buffer
  edma 3, $fa0, 32, $50000
  edma 3, $fa0, 0, $51000

  edma 3, $fa0, 32, $52000
  edma 3, $fa0, 0, $51000


  fname$ = "ana.ln"
  ver = 1
  gosub load_line_file

  poke $40000, $81 ' opt = dest addr MB selector
  poke $40001, $00 ' default to 1st megabyte

  poke $40002, $07 ' opt = enable transparency
  poke $40003, $86 ' opt = set transparency
  poke $40004, $20 ' transparency value
  poke $40005, $00 ' end of options

  poke $40006, $00 ' CMD lsb = COPY
  wpoke $40007, $0000 ' length
  wpoke $40009, $1000 ' source addr
  poke $4000b, $05    ' source bank
  wpoke $4000c, $1000 ' dest addr
  poke $4000e, $05    ' dest bank
  poke $4000f, $00    ' CMD msb (ignore)
  wpoke $40010, $0000 ' modulo (ignore)

  ' init var interface to assembly
  loc = $40036

  ptr = pointer(starx%(0))
  gosub store_ptr

  ptr = pointer(starvx%(0))
  gosub store_ptr
  return


'---------
.store_ptr
'---------
  wpoke loc, ptr
  loc = loc + 2
  return


'--------------
.load_line_file
'-------------- ' (fname$)
  if fname$ = "" then return
  gosub line_file_init
  dopen #2,(fname$),r,u8

  do
    get #2, val&
    if st then exit
    ldata&(didx%) = val&
    didx% = didx% + 1
  loop

  dclose #2
  gosub play_data_init
  return


'--------------
.line_file_init
'--------------
  oldx = -1 : oldy = -1 : oldoffs = 0
  didx% = 0
  group_flag& = 0 : rev_flag& = 0
  offs = 0
  return


'--------------
.draw_starfield
'--------------
  for k = 0 to 20
    poke $50000 + starx%(k)/256 + stary(k) * 80, 46  ' dot
  next k
  return


'--------------
.iter_starfield
'--------------
  bank 0:sys $7e0f:bank 128

  'for k = 0 to 20
  '  starx(k) = mod( (starx(k)-starvx(k)) + 80, 80)
  'next k

  'cursor 0,0
  'for k = 0 to 20
  '  print int(starx%(k)/256), stary(k)
  'next k
  'get key a$
  return


'---------
.page_flip
'---------
  src_addr = $52000
  dest_addr = $50000
  length = 4000
  transp = 32
  gosub transparent_dma

  edma 0, $fa0, $50000, $40800
  edma 0, $fa0, $51000, $ff80000

  ' clear the offscreen buffer
  edma 3, $fa0, 32, $50000
  edma 3, $fa0, 1, $51000
  return


'--------------
.play_data_init
'--------------
  print "{x93}";

  offs=0
  pidx% = 0
  if lastflag = 1 then pidx% = last_group_idx : lastflag = 0
  return

'--------------
.play_data_iter
'--------------
  if pidx% < didx% then begin
    val& = ldata&(pidx%) : pidx% = pidx% + 1
    if ver=3 and val& = $ff then begin
      if pidx% > last_group_idx then last_group_idx = pidx%
      goto pd_endloop
    bend

    'if val& = $ff then group_flag& = 1 : goto pd_endloop
    'if val& = $fe then group_flag& = 0 : sleep .02 : goto pd_endloop
    x = val& and $7f
    if ver=2 then begin
      x = val&
      val& = ldata&(pidx%)
      pidx% = pidx% + 1
      x = x + (val& and $7f) * 256
    bend

    if val& and $80 then rev_flag& = 1: else rev_flag& = 0
    y = ldata&(pidx%) : pidx% = pidx% + 1
    a$ = chr$(ldata&(pidx%)) : pidx% = pidx% + 1

    if ver=2 then begin
      do while x-offs > 78
        gosub scroll_canvas_right
        print "{x13}";chr$(27);"qoffs=";offs;
      loop
    bend

    xx = x-offs : yy = y: cursor xx, yy : gosub draw_char

    if debug=1 then get key z$
      'print "{x13}{x11}";chr$(27);"q x,y,pidx,a$=";x;y;pidx%,asc(a$)
      'get key a$

    ' if group_flag& = 0 then sleep .02
.pd_endloop

  bend

  ' x = x-offs

  return


'---------
.draw_char
'---------
  ' poke $40800 + x + y*80, asc(a$)
  ' poke $ff80000 + x + y*80, rcolor(1)
  
  chr = asc(a$)
  gosub petscii_to_screencode

  if rev_flag& = 1 then chr = chr + 128

  poke $52000 + x + y*80, chr
  ' print a$;
  return


'---------------------
.petscii_to_screencode
'---------------------
  ' Based on the table here:
  ' https://sta.c64.org/cbm64pettoscr.html
  ' - seems like I needed to do a repair to it on the $a0-->$bf range
  if chr>=$00 and chr<=$1f then chr=chr or $80:return
  if chr>=$20 and chr<=$3f then return
  if chr>=$40 and chr<=$5f then chr=chr and $bf:return
  if chr>=$60 and chr<=$7f then chr=chr and $df:return
  if chr>=$80 and chr<=$9f then chr=chr or $40:return
  if chr>=$a0 and chr<=$bf then chr=(chr and $7f) or $40:return ' $bf:return
  if chr>=$c0 and chr<=$fe then chr=chr and $7f:return
  return


'---------------
.transparent_dma
'---------------
  wpoke $40009, src_addr
  wpoke $4000c, dest_addr
  wpoke $40007, length
  poke  $40004, transp
  poke $d702, 4 ' dma list in bank 4
  poke $d701, $00 ' dma list msb
  poke $d705, $00 ' dma list lsb

  return


'------------------
.scroll_canvas_left
'------------------
  for yy = 0 to 49
    edma OP_COPY+DST_DEC+SRC_DEC, {x5F}
           79, $52000 + yy*80 + 78, $52000 + yy*80 + 79
    poke $52000 + yy*80, 32 
  next yy
  return


'-------------------
.scroll_canvas_right
'-------------------
  for yy = 0 to 49
    edma OP_COPY, 79, $52001 + yy*80, $52000 + yy*80
    poke $52000 + 79 + yy*80, 32 
  next yy                
  return
ÿ