#OUTPUT "PETLINE"' DRAW LINES IN 80X50 WITH PETSCII BLOCK CHARS' GIVING A FULL RESOLUTION OF 160X100' Œœ‘≈: ◊HEN … LATER WANT TO MOVE THE LOGIC INTO ASSEMBLY,' CONSIDER REFERENCING GRIM FANDANGO'S Õ≈«¡–Ãœ‘ ASSEMBLY SOURCE:' - HTTPS://GITHUB.COM/GRIM-FANDANGO/MEGAPLOT/BLOB/MASTER/MEGAPLOT.A'--------.DECLARES'--------#DECLARE –…ÿØ‘Ã = 126#DECLARE –…ÿØ‘“ = 124#DECLARE –…ÿØ¬Ã = 123#DECLARE –…ÿØ¬“ = 108#DECLARE –…ÿØ…Œ÷Ø‘Ã = 254#DECLARE –…ÿØ…Œ÷Ø‘“ = 252#DECLARE –…ÿØ…Œ÷Ø¬Ã = 251#DECLARE –…ÿØ…Œ÷Ø¬“ = 236#DECLARE –…ÿØƒ…¡«Ø‘ÃØ¬“ = 127#DECLARE –…ÿØƒ…¡«Ø¬ÃØ‘“ = 255#DECLARE –…ÿØ»Ã…Œ≈Ø¬œ‘ = 98#DECLARE –…ÿØ»Ã…Œ≈Ø‘œ– = 226#DECLARE –…ÿØ÷Ã…Œ≈ØÃ≈∆‘ = 97#DECLARE –…ÿØ÷Ã…Œ≈Ø“…«»‘ = 225#DECLARE –…ÿØŒœŒ≈ = 32#DECLARE –…ÿØ¡ÃÃ = 160#DECLARE –… = 3.141592654269'----.VARS'----#DECLARE X1, Y1, X2, Y2#DECLARE DX, DY, MX, MY, CX, CY#DECLARE CURØCHAR, PIX#DECLARE DIFFX, DIFFY, DELTAX, DELTAY, TANVAL, ANGLE#DECLARE A$, ANG, LINEØLENGTH, K, DEBUG#DECLARE CENTREX, CENTREY, CENTREZ#DECLARE PX(10), PY(10), PLEN, PANG, PIDX, PDIST#DECLARE SQANG#DECLARE CBØANGA, CBØANGB, CBIDX, CBTMP, PZ#DECLARE CBØINCA, CBØINCB, RETØANG, Z$, ZFACT#DECLARE DDX, DDY, SX, SY, E, E2#DECLARE QLIDX, QLCNT#DECLARE QLX1(10), QLY1(10), QLX2(10), QLY2(10)#DECLARE QLVX1, QLVY1, QLVX2, QLVY2#DECLARE QLCLR(10), QLCURCLR, KKGOSUB INIT'----.MAIN'----  PRINT "ì";  PRINT "PETLINE EXAMPLE MENU:"  PRINT "--------------------"  PRINT "1) LINES"  PRINT "2) SQUARE"  PRINT "3) MANY SQUARES"  PRINT "4) DRAW CUBE"  PRINT "5) DRAW MANY CUBES"  PRINT "6) QIX LINES"  GET KEY Z$  IF Z$="1" THEN GOSUB DRAWØLINESØFROMØCENTREØOUT  IF Z$="2" THEN GOSUB DRAWØSQUARE  IF Z$="3" THEN GOSUB DRAWØMANYØSQUARES  IF Z$="4" THEN GOSUB DRAWØCUBE  IF Z$="5" THEN GOSUB DRAWØMANYØCUBES  IF Z$="6" THEN GOSUB DRAWØQIXØLINES  IF Z$>="1" AND Z$<="5" THEN GET KEY Z$  GOTO MAIN  END'--------------.DRAWØQIXØLINES'--------------  ' INIT  QLIDX = 0 : QLCNT = 0  QLX1(QLIDX) = INT(RND(1)*160)  QLY1(QLIDX) = INT(RND(1)*100)  QLX2(QLIDX) = INT(RND(1)*160)  QLY2(QLIDX) = INT(RND(1)*100)  QLCNT = QLCNT + 1  QLVX1 = RND(1)*3 + .5  QLVY1 = RND(1)*3 + .5  QLVX2 = RND(1)*3 + .5  QLVY2 = RND(1)*3 + .5  QLCURCLR = MOD(QLCURCLR + 1, 16)  QLCLR(QLIDX) = QLCURCLR.QLLØLOOP  VSYNC 0  PRINT "ì";  FOR K = 0 TO QLCNT - 1    KK = MOD(QLIDX + K, 10)    SYS $7E0C, QLCLR(KK) + 64    X1 = QLX1(KK)    Y1 = QLY1(KK)    X2 = QLX2(KK)    Y2 = QLY2(KK)    'CURSOR 0,0:PRINT CHR$(27);"QX1,Y1,X2,Y2=",INT(X1),INT(Y1),INT(X2),INT(Y2)    'CURSOR 0,1:PRINT CHR$(27);"QVX1,VY1,VX2,VY2=";QLVX1;QLVY1;QLVX2;QLVY2    GOSUB DRAWØLINE    'CURSOR X1/2,Y1/2:PRINT "+";    'CURSOR X2/2,Y2/2:PRINT "+";    'GET KEY A$  NEXT K  ' CALC NEXT LINE POSITIONS  KK = QLIDX  ' OLD QLIDX  QLIDX = MOD(QLIDX + 1, 10)  IF QLCNT < 10 THEN QLCNT = QLCNT + 1  QLX1(QLIDX) = QLX1(KK) + QLVX1  IF QLX1(QLIDX) >= 160 AND QLVX1 > 0 THEN QLX1(QLIDX)=159 : QLVX1 = -QLVX1  IF QLX1(QLIDX) < 0 AND QLVX1 < 0 THEN QLX1(QLIDX)=0 : QLVX1 = -QLVX1  QLY1(QLIDX) = QLY1(KK) + QLVY1  IF QLY1(QLIDX) >= 100 AND QLVY1 > 0 THEN QLY1(QLIDX)=99 : QLVY1 = -QLVY1  IF QLY1(QLIDX) < 0 AND QLVY1 < 0 THEN QLY1(QLIDX)=0 : QLVY1 = -QLVY1  QLX2(QLIDX) = QLX2(KK) + QLVX2  IF QLX2(QLIDX) >= 160 AND QLVX2 > 0 THEN QLX2(QLIDX)=159 : QLVX2 = -QLVX2  IF QLX2(QLIDX) < 0 AND QLVX2 < 0 THEN QLX2(QLIDX)=0 : QLVX2 = -QLVX2  QLY2(QLIDX) = QLY2(KK) + QLVY2  IF QLY2(QLIDX) >= 100 AND QLVY2 > 0 THEN QLY2(QLIDX)=99 : QLVY2 = -QLVY2  IF QLY2(QLIDX) < 0 AND QLVY2 < 0 THEN QLY2(QLIDX)=0 : QLVY2 = -QLVY2  QLCURCLR = MOD(QLCURCLR + 1, 16)  QLCLR(QLIDX) = QLCURCLR  GOTO QLLØLOOP  RETURN'---------------.DRAWØMANYØCUBES'---------------  CBØINCB = 0  FOR CBØINCA = 0 TO 1.9*–…/4 STEP –…/16    ' PRINT"ì"    GOSUB DRAWØCUBE    ' SLEEP .02  NEXT CBØINCA  CBØINCA = 0  FOR CBØINCB = 0 TO 1.9*–…/2 STEP –…/16    ' PRINT"ì"    GOSUB DRAWØCUBE    ' SLEEP .02  NEXT CBØINCB  RETURN  '---------.DRAWØCUBE'---------  PDIST = 45  CBIDX = 0  CBØANGB = ATN(1/SQR(2))  FOR CBØANGA = –… / 4 TO 1.9 * –… STEP –…/2    CBTMP = PDIST * COS(CBØANGB)    PZ = CBTMP * SIN(CBØANGA)    PY(CBIDX) = PDIST * SIN(CBØANGB)    PX(CBIDX) = CBTMP * COS(CBØANGA)    GOSUB ROTATEØINCA    GOSUB ROTATEØINCB    PX(CBIDX) = CENTREX + PX(CBIDX) - PZ * ZFACT / 4    PY(CBIDX) = CENTREY + PY(CBIDX) + PZ * ZFACT    'PRINT "PX(";CBIDX;")=";PX(CBIDX);", PY(";CBIDX;")=";PY(CBIDX)    CBIDX = CBIDX + 1  NEXT CBØANGA   PLEN = 4  GOSUB DRAWØPOLY  ' DRAW LINES FROM POLY  CBIDX = 0  CBØANGB = -ATN(1/SQR(2))  FOR CBØANGA = –… / 4 TO 1.9 * –… STEP –…/2    X1 = PX(CBIDX)    Y1 = PY(CBIDX)    CBTMP = PDIST * COS(CBØANGB)    PZ = CBTMP * SIN(CBØANGA)    PY(CBIDX) = PDIST * SIN(CBØANGB)    PX(CBIDX) = CBTMP * COS(CBØANGA)    GOSUB ROTATEØINCA    GOSUB ROTATEØINCB    PX(CBIDX) = CENTREX + PX(CBIDX) - PZ * ZFACT / 4    PY(CBIDX) = CENTREY + PY(CBIDX) + PZ * ZFACT    X2 = PX(CBIDX)    Y2 = PY(CBIDX)    GOSUB DRAWØLINE    CBIDX = CBIDX + 1  NEXT CBØANGA  PLEN = 4  GOSUB DRAWØPOLY  RETURN'-----------.ROTATEØINCA'-----------  ' ROTATE ALONG Y-AXIS BY INCA  DIFFX = PX(CBIDX)  DIFFY = PZ  CBTMP = SQR(DIFFX*DIFFX + DIFFY*DIFFY)  GOSUB ATAN2  ' RETURNS ANGLE  ANGLE = ANGLE + CBØINCA  PX(CBIDX) = CBTMP * COS(ANGLE)  PZ = CBTMP * SIN(ANGLE)   RETURN'-----------.ROTATEØINCB'-----------  ' ROTATE ALONG Z-AXIS BY INCB  DIFFX = PX(CBIDX)  DIFFY = PY(CBIDX)  CBTMP = SQR(DIFFX*DIFFX + DIFFY*DIFFY)  GOSUB ATAN2  ' RETURNS ANGLE  ANGLE = ANGLE + CBØINCB  PX(CBIDX) = CBTMP * COS(ANGLE)  PY(CBIDX) = CBTMP * SIN(ANGLE)   RETURN'-----------------.DRAWØMANYØSQUARES'-----------------  FOR SQANG = 0 TO –…/2 STEP –… / 8    GOSUB DRAWØSQUARE  NEXT SQANG  RETURN'-----------.DRAWØSQUARE'-----------  PDIST = 45  PANG = SQANG - 3 * –… / 4  PX(0) = CENTREX + PDIST * COS(PANG)  PY(0) = CENTREY + PDIST * SIN(PANG)  PANG = SQANG - –… / 4  PX(1) = CENTREX + PDIST * COS(PANG)  PY(1) = CENTREY + PDIST * SIN(PANG)  PANG = SQANG + –… / 4  PX(2) = CENTREX + PDIST * COS(PANG)  PY(2) = CENTREY + PDIST * SIN(PANG)  PANG = SQANG + 3 * –… / 4  PX(3) = CENTREX + PDIST * COS(PANG)  PY(3) = CENTREY + PDIST * SIN(PANG)  PLEN = 4  GOSUB DRAWØPOLY  RETURN'---------.DRAWØPOLY'---------  FOR PIDX = 0 TO PLEN-2    X1 = PX(PIDX) : Y1 = PY(PIDX)    X2 = PX(PIDX+1) : Y2 = PY(PIDX+1)    ' PRINT "X1=";X1;", Y1=";Y1;", X2=";X2;", Y2=";Y2    ' GET KEY A$    GOSUB DRAWØLINE  NEXT PIDX  X1 = PX(PLEN-1) : Y1 = PY(PLEN-1)  X2 = PX(0) : Y2 = PY(0)  GOSUB DRAWØLINE  RETURN'--------------------------.DRAWØLINESØFROMØCENTREØOUT'--------------------------  FOR ANG = 0 TO 2*–… STEP –… / 8    X1 = 80    Y1 = 50    X2 = INT(80 + 30 * COS(ANG))    Y2 = INT(50 + 30 * SIN(ANG))    ' CURSOR 0,20:PRINT CHR$(27);"QX1 =";X1;", Y1 =";Y1    ' CURSOR 0,21:PRINT CHR$(27);"QX2 =";X2;", Y2 =";Y2    ' GET KEY A$    ' IF A$="D" THEN DEBUG = 1: ELSE DEBUG = 0    GOSUB DRAWØLINE  NEXT ANG  RETURN'---------.DRAWØLINE'---------  SYS $7E03  X1 = MOD(INT(X1)+256,256)  Y1 = MOD(INT(Y1)+256,256)  X2 = MOD(INT(X2)+256,256)  Y2 = MOD(INT(Y2)+256,256)  SYS $7E09, X1, Y1, X2, Y2  RETURN  '-----.ATAN2'-----  IF DIFFX = 0 THEN BEGIN    IF DIFFY<0 THEN ANGLE = - –…/2    IF DIFFY>0 THEN ANGLE = –…/2  BEND:ELSE BEGIN    TANVAL = DIFFY / DIFFX    ANGLE = ATN(TANVAL)  ' THIS IS RANGE -90DEG TO 90DEG    IF DIFFX<0 THEN BEGIN     IF DIFFY<0 THEN ANGLE = ANGLE - –…:ELSE ANGLE = ANGLE + –…    BEND  BEND  RETURN'----------.DRAWØPIXEL'----------  BANK 0:SYS $7E06, MOD(CX+256, 256), MOD(CY+256, 256), 5  RETURN  ' PIXEL CROPPED?  IF CX<0 OR CX>159 OR CY<0 OR CY>99 THEN RETURN  DX = INT(CX/2) : DY = INT(CY/2)  MX = MOD(INT(CX),2) : MY = MOD(INT(CY),2)    ' CURSOR 0,16:PRINT CHR$(27);"QHX =";HX;", HY =";HY    ' CURSOR 0,17:PRINT CHR$(27);"QMX =";MX;", MY =";MY  CURØCHAR = PEEK($40800 + DX + DY * 80)  GOSUB READØONØPIXELS  IF MX = 0 AND MY = 0 THEN PIX = PIX OR 1  IF MX = 1 AND MY = 0 THEN PIX = PIX OR 2  IF MX = 0 AND MY = 1 THEN PIX = PIX OR 4  IF MX = 1 AND MY = 1 THEN PIX = PIX OR 8  GOSUB SETØONØPIXELS  POKE $40800 + DX + DY * 80, CURØCHAR  RETURN'--------------.READØONØPIXELS'--------------  PIX = 0 ' BITFIELDS: TL = 1, TR = 2, BL = 4, BR = 8  IF CURØCHAR = –…ÿØ‘Ã THEN PIX = 1:RETURN  IF CURØCHAR = –…ÿØ‘“ THEN PIX = 2:RETURN  IF CURØCHAR = –…ÿØ¬Ã THEN PIX = 4:RETURN  IF CURØCHAR = –…ÿØ¬“ THEN PIX = 8:RETURN  IF CURØCHAR = –…ÿØ…Œ÷Ø‘Ã THEN PIX=14:RETURN  IF CURØCHAR = –…ÿØ…Œ÷Ø‘“ THEN PIX=13:RETURN  IF CURØCHAR = –…ÿØ…Œ÷Ø¬Ã THEN PIX=11:RETURN  IF CURØCHAR = –…ÿØ…Œ÷Ø¬“ THEN PIX=7:RETURN  IF CURØCHAR = –…ÿØƒ…¡«Ø‘ÃØ¬“ THEN PIX=9:RETURN  IF CURØCHAR = –…ÿØƒ…¡«Ø¬ÃØ‘“ THEN PIX=6:RETURN  IF CURØCHAR = –…ÿØ»Ã…Œ≈Ø¬œ‘ THEN PIX=12:RETURN  IF CURØCHAR = –…ÿØ»Ã…Œ≈Ø‘œ– THEN PIX=3:RETURN  IF CURØCHAR = –…ÿØ÷Ã…Œ≈ØÃ≈∆‘ THEN PIX=5:RETURN  IF CURØCHAR = –…ÿØ÷Ã…Œ≈Ø“…«»‘ THEN PIX=10:RETURN  IF CURØCHAR = –…ÿØ¡ÃÃ THEN PIX=15:RETURN  RETURN'-------------.SETØONØPIXELS'-------------  IF PIX = 0 THEN CURØCHAR = –…ÿØŒœŒ≈:RETURN  IF PIX = 1 THEN CURØCHAR = –…ÿØ‘Ã:RETURN  IF PIX = 2 THEN CURØCHAR = –…ÿØ‘“:RETURN  IF PIX = 3 THEN CURØCHAR = –…ÿØ»Ã…Œ≈Ø‘œ–:RETURN  IF PIX = 4 THEN CURØCHAR = –…ÿØ¬Ã:RETURN  IF PIX = 5 THEN CURØCHAR = –…ÿØ÷Ã…Œ≈ØÃ≈∆‘:RETURN  IF PIX = 6 THEN CURØCHAR = –…ÿØƒ…¡«Ø¬ÃØ‘“:RETURN  IF PIX = 7 THEN CURØCHAR = –…ÿØ…Œ÷Ø¬“:RETURN  IF PIX = 8 THEN CURØCHAR = –…ÿØ¬“:RETURN  IF PIX = 9 THEN CURØCHAR = –…ÿØƒ…¡«Ø‘ÃØ¬“:RETURN  IF PIX = 10 THEN CURØCHAR = –…ÿØ÷Ã…Œ≈Ø“…«»‘:RETURN  IF PIX = 11 THEN CURØCHAR = –…ÿØ…Œ÷Ø¬Ã:RETURN  IF PIX = 12 THEN CURØCHAR = –…ÿØ»Ã…Œ≈Ø¬œ‘:RETURN  IF PIX = 13 THEN CURØCHAR = –…ÿØ…Œ÷Ø‘“:RETURN  IF PIX = 14 THEN CURØCHAR = –…ÿØ…Œ÷Ø‘Ã:RETURN  IF PIX = 15 THEN CURØCHAR = –…ÿØ¡ÃÃ:RETURN  RETURN'----.INIT'----  BANK 0:BLOAD "MEGAPLOT"  SYS $7E03 ' INIT  CENTREX = 80 : CENTREY = 50  PRINT CHR$(27);"5";CHR$(147);  ZFACT = COS(–…/4)  RETURN  