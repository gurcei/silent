!to "megaplot.prg", cbm

//SCRNBASE = $0800
//COLRBASE = $d800
COLRBASE = $0000 // Fixed to Bank ff8
ROWPTR = $18
COLPTR = $1c

* = $7e00

// basicstub:		!byte $00,$0a,$20,$0a,$00,$fe,$02,$20
//				!byte $30,$00,$16,$20,$14,$00,$9e,$20
//				!byte $24,$32,$30,$31,$38,$00,$00,$00

// jump table
// ----------
  jmp init_and_plot	// a = x-coord, x = y-coord, y = colour
    				// (equivalent to original program's behaviour)
  jmp init          // a 'one-time' init, so that future draw calls don't need to repeatedly init
  jmp plot          // plot(a=colour, x=x-coord, y=y-coord)
  jmp line          // line(a=x1, x=y1, y=x2, z=y2, s=colour)

//-----------
init_and_plot:
//-----------
				pha
				phx
				phy
				jsr init
				ply
				plx
				pla

				jsr plot
				rts

//---
init:
//---
// populate properties and initialise
				// 40 or 80 column screen?
				lda #80
				sta xmode4080
				lda $d031
				and #$80
				bne +
				lda #40
				sta xmode4080

				
+				// 25 or 50 row screen?
				lda #50
				sta ymode2550
				lda $d031
				and #$08
				bne +
				lda #25
				sta ymode2550

				jsr init2

+				rts


//----
init2:
//----
				lda #$00
				sta virtual
				sta xhalf
				sta yhalf

				// init high word of COLPTR to be $0ff8
				lda #$0f
				sta COLPTR + 3
				lda #$f8
				sta COLPTR + 2

				// init high word of ROWPTR to be LO=SCRNPTRBNK($D062) HI=SCRNPTRMB($D063.0-3)
				lda $d063
				and #$0f
				sta ROWPTR + 3
				lda $d062
				sta ROWPTR + 2

				rts


//---
plot:
//---
				sta xpos
				stx ypos
				sty colour

_plot:
				jsr init2

				jsr check_xy_in_range
				bcc +
				rts

+				jsr find_char_positions	// sets screenx, screeny,
										// xhalf and yhalf (if odd, set to $ff, if even, set to $00)


				jsr which_char_at_xy 	// for given x,y, existing battenburg char is stored in 'virtual'
										// (if one exists, otherwise, virtual = 0)

				jsr update_char_at_xy	// based on xhalf,yhalf, decide which battenburg pixel to update

				rts


//---
line:
//---
	sei
	sta x1
	stx y1
	sty x2
	stz y2
	ldx #$05
	stx colour

	jsr init

	// borrowed from: www.baeldung.com/cs/bresenhams-line-algorithm

	// ddx = abs(x2-x1)
	lda x2
	sec
	sbc x1
	bpl +

	eor #$ff
	clc
	adc #$01

+	sta ddx


	// if x1 < x2 then sx = 1 : else sx = -1
	lda #$01
	sta sx
	lda x1
	cmp x2
	
	bmi +
	lda #$ff
	sta sx
	
	// ddy = -abs(y2-y1)
+	lda y2
	sec
	sbc y1
	bmi +

	eor #$ff
	clc
	adc #$01

+	sta ddy

	// if y1 < y2 then sy = 1 : else sy = -1
	lda #$01
	sta sy
	lda y1
	cmp y2
	
	bmi +
	lda #$ff
	sta sy
	
	// e = ddx + ddy
+	lda ddx
	clc
	adc ddy
	sta e
	
	// xpos = x1 : ypos = y1
	lda x1
	sta xpos
	lda y1
	sta ypos

	// do while 1
pixel_loop:
		// gosub draw_pixel
		jsr _plot

		//if xpos = (x2) and ypos = y2 then exit
		lda xpos
		cmp x2
		bne +

		lda ypos
		cmp y2
		bne +
		cli
		rts
	
		// e2 = 2 * e
+ 		lda e
		clc
		asl
		sta e2

		// if e2 >= ddy then begin
		lda e2
		cmp ddy
		bmi ++
			// if xpos = x2 then exit
			lda xpos
			cmp x2
			bne +
			cli
			rts

			// e = e + ddy
+			clc
			lda e
			adc ddy
			sta e

			// xpos = xpos + sx
			clc
			lda xpos
			adc sx
			sta xpos
		// bend


		// if e2 <= ddx then begin
++		lda e2
		cmp ddx
		bmi +
		beq +

		jmp pixel_loop

+			// if ypos = y2 then exit
			lda ypos
			cmp y2
			bne +
			cli
			rts

			// e = e + ddx
+			clc
			lda e
			adc ddx
			sta e

			// ypos = ypos + sy
			clc
			lda ypos
			adc sy
			sta ypos
		// bend
	
	// loop
+	jmp pixel_loop

	cli
	rts

//---------------
update_char_at_xy:
//---------------
				// if on left, bits 1 or 3
				lda xhalf
				bne SetRightBit  // plot must be on the right of the battenburg
				// since bits 1 or 3 is set, we are on the left - top left or bottom left?
				lda yhalf
				beq SetTopLeft
				ldx #$04 // bottom left
				jmp Combine
SetTopLeft:		ldx #$01 // top left	
				jmp Combine

SetRightBit:	lda yhalf
				beq SetTopRight
				ldx #$08
				jmp Combine
SetTopRight:	ldx #$02

Combine:		// combine the new bit with those of any pre-existing bits 
				txa
				ora virtual
				tax

				// What's the character corresponding to the combined bit pattern?
NextCharOut:	lda bitpatterns,x
				
Plot:			phy
				plz
				sta [ROWPTR],z
				lda colour
				sta [COLPTR],z

DumpReg:		ldx ROWPTR
				ldy ROWPTR + 1
				ldz xhalf
				rts

//---------------
check_xy_in_range:
//---------------
				// don't draw negative x
				lda xpos
				bpl +
				rts

				// don't draw negative y
+				lda ypos
				bpl +
				rts

+				lda xmode4080
				cmp #80
				beq ValidateX80

ValidateX40:	lda xpos 
				cmp #80
				bcc xok
				sec
				rts // if out of range, don't draw

				// validate values
ValidateX80:		lda xpos
				cmp #160
				bcc xok
				sec
				rts	// if out of range, don't draw

xok:			lda ymode2550
				cmp #50
				beq ValidateY50

ValidateY25:	lda ypos
				cmp#50
				bcc yok
				sec
				rts // if out of range, don't draw

ValidateY50:	lda ypos
				cmp#100
				bcc yok
				sec
				rts // if out of range, don't draw

yok:			clc
				rts


//-----------------
find_char_positions:
//-----------------
				// find character positions
				//divide x by 2
				clc
				lda xpos
				ror
				sta screenx
				// is it an odd number?  Then we need a right half pixel to be set
				bcc +
				lda #$ff
				sta xhalf

				//divide y by 2
+				clc
				lda ypos
				ror
				sta screeny
				// is it an odd number?  Then we need a bottom half pixel to be set
				bcc +
				lda #$ff
				sta yhalf

+				rts


//-----------------------------
init_screen_and_colour_pointers:
//-----------------------------
				// ldx #<SCRNBASE
				// ldy #>SCRNBASE
				ldx $d060	// SCRNPTRLSB
				ldy $d061	// SCRNPTRMSB
				stx ROWPTR
				sty ROWPTR + 1

				ldx #<COLRBASE
				ldy #>COLRBASE
				stx COLPTR
				sty COLPTR + 1
				rts


//-------------------------------
update_pointers_to_start_of_y_row:
//-------------------------------
				ldx #$00
				ldy screeny
				iny

rowloopy:		// loop through the rows until we get to the start of the screen row 
				dey
				beq +
				clc
				lda ROWPTR
				adc xmode4080,x
				sta ROWPTR
				clc 
				lda COLPTR
				adc xmode4080,x
				sta COLPTR
				bcs nextpagey
				jmp rowloopy

nextpagey:		inc ROWPTR + 1
				inc COLPTR + 1
				jmp rowloopy		

+				rts


//--------------------------------
check_for_battenburg_char_at_x_col:
//--------------------------------
				// y is the x coordinate to print to
				ldy screenx

				// Is there already a plot character in the box?
CheckChar:		// Is it in the list?  If so, which bit pattern?
				ldx #$00
NextChar:		lda bitpatterns,x
				phy
				plz
				cmp [ROWPTR],z
				beq CheckDone
				inx
				cpx #$10
				bne NextChar

CheckDone:		// if we reach the end of the list there isn't a battenburg so just go ahead and plot
				cpx #$10
				beq +

				// there is already a plot point in the character square, store its nybble representation
				stx virtual

+				rts


//--------------
which_char_at_xy:
//--------------
				lda #$00
				sta virtual

				jsr init_screen_and_colour_pointers
			
				jsr update_pointers_to_start_of_y_row

				jsr check_for_battenburg_char_at_x_col	// if exists, screen-code char stored in 'virtual'

				rts


// ---------
// variables
// ---------
xpos:			!byte $00
ypos:			!byte $00
colour:			!byte $00
screenx:		!byte $00
screeny:		!byte $00
xhalf:			!byte $00 // ff if the point is on the right of the character square
yhalf:			!byte $00 // ff if the point is on the bottom of the character square
linestartscrn:	!word $0800
xmode4080:       !byte 80
ymode2550:		!byte 50
bitpatterns:	!byte $20,$7e,$7c,$e2,$7b,$61,$ff,$ec,$6c,$7f,$e1,$fb,$62,$fc,$fe,$a0
// descriptions:      spc, TL, TR, hT, BL, vL,  /,iBR, BR,  \, vR,iBL, hB,iTR,iTL,all
virtual:		!byte $00
scrnbase:		!byte $00, $00, $00, $00
colrbase:		!byte $00, $00, $00, $00
x1:			!byte $00
y1:			!byte $00
x2:			!byte $00
y2:			!byte $00
ddx:			!byte $00
ddy:			!byte $00
sx:			!byte $00
sy:			!byte $00
e:			!byte $00
e2:			!byte $00
