!to "megaplot.prg", cbm

//SCRNBASE = $0800
//COLRBASE = $d800
COLRBASE = $0000 // Fixed to Bank ff8
ROWPTR = $18
COLPTR = $1c

* = $7e00

// basicstub:		!byte $00,$0a,$20,$0a,$00,$fe,$02,$20
//				!byte $30,$00,$16,$20,$14,$00,$9e,$20
//				!byte $24,$32,$30,$31,$38,$00,$00,$00

// jump table
// ----------
  jmp init_and_plot	// a = x-coord, x = y-coord, y = colour
    				// (equivalent to original program's behaviour)
  jmp init          // a 'one-time' init, so that future draw calls don't need to repeatedly init
  jmp plot          // plot(a=colour, x=x-coord, y=y-coord)
  jmp line          // line(a=x1, x=y1, y=x2, z=y2, s=colour)

//-----------
init_and_plot:
//-----------
				pha
				phx
				phy
				jsr init
				ply
				plx
				pla

				jsr plot
				rts

//---
init:
//---
// populate properties and initialise
				// 40 or 80 column screen?
				lda #80
				sta xmode4080
				lda $d031
				and #$80
				bne +
				lda #40
				sta xmode4080

				
+				// 25 or 50 row screen?
				lda #50
				sta ymode2550
				lda $d031
				and #$08
				bne +
				lda #25
				sta ymode2550

				jsr init2

+				rts


//----
init2:
//----
				lda #$00
				sta virtual
				sta xhalf
				sta yhalf

				// init high word of COLPTR to be $0ff8
				lda #$0f
				sta COLPTR + 3
				lda #$f8
				sta COLPTR + 2

				// init high word of ROWPTR to be LO=SCRNPTRBNK($D062) HI=SCRNPTRMB($D063.0-3)
				lda $d063
				and #$0f
				sta ROWPTR + 3
				lda $d062
				sta ROWPTR + 2

				rts


//---
plot:
//---
				sta xpos
				stx ypos
				sty colour

				jsr init2

				jsr check_xy_in_range
				bcc +
				rts

+				jsr find_char_positions	// sets screenx, screeny,
										// xhalf and yhalf (if odd, set to $ff, if even, set to $00)


				jsr which_char_at_xy 	// for given x,y, existing battenburg char is stored in 'virtual'
										// (if one exists, otherwise, virtual = 0)

				jsr update_char_at_xy	// based on xhalf,yhalf, decide which battenburg pixel to update

				rts


//---
line:
//---
	sta x1
	stx y1
	sty x2
	stz y2
	tsx
	stx colour

	// diffx = x2-x1
	// diffy = y2-y1

	// line_length = sqrt(diffx^2 + diffy^2)

	// if diffx = 0 then begin
	//   deltax = 0
	//   if diffy < 0 then deltay = -1
	//   if diffy > 0 then deltay == 1
	// bend:else begin
	//   gosub atan2
	//   deltax = cos(angle)
	//   deltay = sin(angle)
	// bend

	// cx = x1 : cy = y1
	// for k = 1 to line_length
	//   gosub draw_pixel
	//   cx = cx + deltax
	//   cy = cy + deltay
	// next k
	// gosub draw_pixel
	rts

//---------------
update_char_at_xy:
//---------------
				// if on left, bits 1 or 3
				lda xhalf
				bne SetRightBit  // plot must be on the right of the battenburg
				// since bits 1 or 3 is set, we are on the left - top left or bottom left?
				lda yhalf
				beq SetTopLeft
				ldx #$04 // bottom left
				jmp Combine
SetTopLeft:		ldx #$01 // top left	
				jmp Combine

SetRightBit:	lda yhalf
				beq SetTopRight
				ldx #$08
				jmp Combine
SetTopRight:	ldx #$02

Combine:		// combine the new bit with those of any pre-existing bits 
				txa
				ora virtual
				tax

				// What's the character corresponding to the combined bit pattern?
NextCharOut:	lda bitpatterns,x
				
Plot:			phy
				plz
				sta [ROWPTR],z
				lda colour
				sta [COLPTR],z

DumpReg:		ldx ROWPTR
				ldy ROWPTR + 1
				ldz xhalf
				rts

//---------------
check_xy_in_range:
//---------------
				// don't draw negative x
				lda xpos
				bpl +
				rts

				// don't draw negative y
+				lda ypos
				bpl +
				rts

+				lda xmode4080
				cmp #80
				beq ValidateX80

ValidateX40:	lda xpos 
				cmp #80
				bcc xok
				sec
				rts // if out of range, don't draw

				// validate values
ValidateX80:		lda xpos
				cmp #160
				bcc xok
				sec
				rts	// if out of range, don't draw

xok:			lda ymode2550
				cmp #50
				beq ValidateY50

ValidateY25:	lda ypos
				cmp#50
				bcc yok
				sec
				rts // if out of range, don't draw

ValidateY50:	lda ypos
				cmp#100
				bcc yok
				sec
				rts // if out of range, don't draw

yok:			clc
				rts


//-----------------
find_char_positions:
//-----------------
				// find character positions
				//divide x by 2
				clc
				lda xpos
				ror
				sta screenx
				// is it an odd number?  Then we need a right half pixel to be set
				bcc +
				lda #$ff
				sta xhalf

				//divide y by 2
+				clc
				lda ypos
				ror
				sta screeny
				// is it an odd number?  Then we need a bottom half pixel to be set
				bcc +
				lda #$ff
				sta yhalf

+				rts


//-----------------------------
init_screen_and_colour_pointers:
//-----------------------------
				// ldx #<SCRNBASE
				// ldy #>SCRNBASE
				ldx $d060	// SCRNPTRLSB
				ldy $d061	// SCRNPTRMSB
				stx ROWPTR
				sty ROWPTR + 1

				ldx #<COLRBASE
				ldy #>COLRBASE
				stx COLPTR
				sty COLPTR + 1
				rts


//-------------------------------
update_pointers_to_start_of_y_row:
//-------------------------------
				ldx #$00
				ldy screeny
				iny

rowloopy:		// loop through the rows until we get to the start of the screen row 
				dey
				beq +
				clc
				lda ROWPTR
				adc xmode4080,x
				sta ROWPTR
				clc 
				lda COLPTR
				adc xmode4080,x
				sta COLPTR
				bcs nextpagey
				jmp rowloopy

nextpagey:		inc ROWPTR + 1
				inc COLPTR + 1
				jmp rowloopy		

+				rts


//--------------------------------
check_for_battenburg_char_at_x_col:
//--------------------------------
				// y is the x coordinate to print to
				ldy screenx

				// Is there already a plot character in the box?
CheckChar:		// Is it in the list?  If so, which bit pattern?
				ldx #$00
NextChar:		lda bitpatterns,x
				phy
				plz
				cmp [ROWPTR],z
				beq CheckDone
				inx
				cpx #$10
				bne NextChar

CheckDone:		// if we reach the end of the list there isn't a battenburg so just go ahead and plot
				cpx #$10
				beq +

				// there is already a plot point in the character square, store its nybble representation
				stx virtual

+				rts


//--------------
which_char_at_xy:
//--------------
				lda #$00
				sta virtual

				jsr init_screen_and_colour_pointers
			
				jsr update_pointers_to_start_of_y_row

				jsr check_for_battenburg_char_at_x_col	// if exists, screen-code char stored in 'virtual'

				rts


// ---------
// variables
// ---------
xpos:			!byte $00
ypos:			!byte $00
colour:			!byte $00
screenx:		!byte $00
screeny:		!byte $00
xhalf:			!byte $00 // ff if the point is on the right of the character square
yhalf:			!byte $00 // ff if the point is on the bottom of the character square
linestartscrn:	!word $0800
xmode4080:       !byte 80
ymode2550:		!byte 50
bitpatterns:	!byte $20,$7e,$7c,$e2,$7b,$61,$ff,$ec,$6c,$7f,$e1,$fb,$62,$fc,$fe,$a0
// descriptions:      spc, TL, TR, hT, BL, vL,  /,iBR, BR,  \, vR,iBL, hB,iTR,iTL,all
virtual:		!byte $00
scrnbase:		!byte $00, $00, $00, $00
colrbase:		!byte $00, $00, $00, $00
x1:			!byte $00
y1:			!byte $00
x2:			!byte $00
y2:			!byte $00

