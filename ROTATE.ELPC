' rotate screen contents
#output "rotate"
' 4.0800 = screen pointer
' 4.4000 = 96x96 clrbox canvas (9216 bytes)
' 4.6400 = free

.defines
'-------
#define OP_COPY = 0
#define OP_MIX  = 1
#define OP_SWAP = 2
#define OP_FILL = 3

#declare HOTREG_7 = $d05d
#declare SCRNPTRLSB = $d060
#declare SCRNPTRBNK = $d062

#declare t, x, y, colr, ang, xinc, yinc, tx, ty, txinc, tyinc
#declare y1add
#declare xfrac, yfrac
#declare box_ang, cx, cy, hyp
#define PI = 3.1415926535
#declare pl_rad, pl_ang, pl_dir, pl_clr
#declare a$
#declare state, k

#declare txt_k, wxx, wyy, fname$, fidx%, ver(2)
#declare char_cnt, char_idx%(60), char_width%(60), max_width
#declare ldata&(2,12288), didx%(2), pidx%(2), val&
#declare oldx, oldy, oldoffs(2), offs(2)
#declare group_flag&, rev_flag&(2), lastflag, last_group_idx
#declare dxx, dyy, debug, addr, chr, chrclr

#declare s$, ret, wc_flag, wc_chr, itercnt, lyr_t

#declare scroll_flag = 0

.main
'----
  gosub init
  s$ = "hello world"
  chrclr = 5
  txt_k = 1
  wxx = 0 : wyy = 0

.mn_loop
  gosub rotate_logic
  gosub draw_content
  gosub iter_write_text
  gosub page_flip
  goto mn_loop

.page_flip
'---------
  bank 0:sys $7e15:bank 128
  edma 3, $fa0, 32+128, $50000
  return

.init
'----
  ^^bload "asmrotate",b0
  bank 0:bload "asmhelper":bank 128

  gosub init_writer

  print chr$(27);"5";chr$(147);
  ang = 2*PI + .1

  state = 0
  pl_rad = 0
  pl_ang = 0
  pl_dir = 0
  pl_clr = 0

  ' clear 80x50 chars and colour ram
  edma 3, 4000, 160, $40800
  edma 3, 4000, 6, $ff80000

  ' clear 96x96 array
  edma OP_FILL, 96*96, 0, $44000

  ' clear the offscreen buffer
  edma 3, $fa0, 32+128, $50000
  edma 3, $fa0, 0, $51000

  edma 3, $fa0, 32, $52000
  edma 3, $fa0, 0, $53000

  edma 3, $fa0, 32, $54000
  edma 3, $fa0, 0, $55000

  ' prepare dma list info
  poke $40000, $81 ' opt = dest addr MB selector
  poke $40001, $00 ' default to 1st megabyte

  poke $40002, $07 ' opt = enable transparency
  poke $40003, $86 ' opt = set transparency
  poke $40004, $20 ' transparency value
  poke $40005, $00 ' end of options

  poke $40006, $00 ' CMD lsb = COPY
  wpoke $40007, $0000 ' length
  wpoke $40009, $1000 ' source addr
  poke $4000b, $05    ' source bank
  wpoke $4000c, $1000 ' dest addr
  poke $4000e, $05    ' dest bank
  poke $4000f, $00    ' CMD msb (ignore)
  wpoke $40010, $0000 ' modulo (ignore)

  return


.rotate_logic
'------------
  ang = ang - .1
  if ang < 0 then ang = ang + (2 * PI)
  hyp = sqr(25*25+40*40) * 65536
  xinc = cos(ang) * 65536
  yinc = sin(ang) * 65536
  txinc = cos(ang+PI/2) * 65536
  tyinc = sin(ang+PI/2) * 65536
  box_ang = atn(-25/-40)+ PI +ang
  if box_ang < 0 then box_ang = box_ang + (2 * PI)
  tx = hyp * cos(box_ang) + 48 * 65536
  ty = hyp * sin(box_ang) + 48 * 65536
  cx = tx
  cy = ty
  xfrac = 0
  yfrac = 0
  y1add = 0
  return


.draw_content
'------------
  gosub plot_iteration
  gosub plot_iteration
  gosub asm_rotation
  ' gosub basic_rotation

  'cursor 0,0:print chr$(27);"q tx=";tx;", ty=";ty;
  'cursor 0,1:print chr$(27);"q ang=";ang;", hyp=";hyp;
  'cursor 0,2:print chr$(27);"q xinc=";xinc;", yinc=";yinc;
  'cursor 0,3:print chr$(27);"q txinc=";txinc;", tyinc=";tyinc;
  'get key a$

  return


.plot_iteration
'--------------
  x = 48 + cos(pl_ang) * pl_rad
  y = 48 + sin(pl_ang) * pl_rad

  poke $44000 + x + int(y) * 96, pl_clr + 64

  pl_ang = pl_ang + .025
  if pl_ang > 2 * PI then pl_ang = pl_ang - 2 * PI

  pl_rad = pl_rad + .05
  if pl_rad > 30 then begin
    pl_rad=0
    pl_clr = pl_clr + 1
    if pl_clr = 16 then state = state + 1
    pl_ang = .3926 * pl_clr
  bend

  return


.asm_rotation
'------------
  ' ASSEMBLY version
  if xinc < 0 then xinc = xinc + 4294967296
  if yinc < 0 then yinc = yinc + 4294967296
  if txinc < 0 then txinc = txinc + 4294967296
  if tyinc < 0 then tyinc = tyinc + 4294967296

  wpoke $1a00, mod(tx,65536)
  wpoke $1a02, tx/65536

  wpoke $1a04, mod(ty, 65536)
  wpoke $1a06, ty/65536

  wpoke $1a08, mod(xinc,65536)
  wpoke $1a0a, xinc/65536

  wpoke $1a0c, mod(yinc, 65536)
  wpoke $1a0e, yinc/65536

  wpoke $1a10, mod(txinc, 65536)
  wpoke $1a12, txinc/65536

  wpoke $1a14, mod(tyinc, 65536)
  wpoke $1a16, tyinc/65536

  bank 0:sys $1800:bank 128

  return


.basic_rotation
'--------------
  ' BASIC version
  for y = 0 to 49
    cx = tx
    cy = ty
    for x = 0 to 79
      poke $ff80000 + x + y1add, peek($44000 + cx/65536 + int(cy/65536) * 96)
      cx = cx + xinc
      cy = cy + yinc
    next x
    tx = tx + txinc
    ty = ty + tyinc
    y1add = y1add + 80
  next y

  get key a$

  return


'-----------
.init_writer
'-----------
  txt_k = 0
  wxx = 0 : wyy = 0

  fname$ = "abc.ln"
  fidx% = 2
  ver(fidx%) = 3
  gosub load_line_file

  char_cnt = 0
  char_idx%(0) = 0
  char_width%(0) = 0
  max_width = 0

  k = 0
  do while k < didx%(fidx%)
    ' get x value
    val& = ldata&(fidx%, k)
    k=k+1

    if val& = $ff then begin
      ' keep an array of widths of each letter
      char_width%(char_cnt)=max_width

      ' print "char_width(";char_cnt;") = ";max_width
      ' get key z$

      max_width = 0
      char_cnt=char_cnt+1

      ' keep an array of indices to each drawn letter
      char_idx%(char_cnt) = k
      'print "char_idx%(";char_cnt;")=";k
      'get key a$
    bend

    if val& = $ff then goto cont_loop

    val& = val& and $7f
    if val& > max_width then max_width = val&
    
    k=k+1  ' skip y value
    k=k+1  ' skip char 

.cont_loop
  loop

  return


'--------------
.load_line_file
'-------------- ' (fname$)
  if fname$ = "" then return
  gosub line_file_init
  dopen #2,(fname$),r,u8

  do
    get #2, val&
    if st then exit
    ldata&(fidx%, didx%(fidx%)) = val&
    didx%(fidx%) = didx%(fidx%) + 1
  loop

  dclose #2
  gosub play_data_init
  return


'---------------
.iter_write_text
'---------------
  ret = 0

  'if wc_space>0 then begin
  '  wxx=wxx+1
  '  wc_space=wc_space-1
  '
  '  lyr_t = lyr_t + 1
  '  if mod(lyr_t, 1) = 0 then gosub scroll_canvas_right:wxx=wxx-1
  '
  '  return
  'bend

  if wc_flag = 0 and txt_k > 0 and txt_k <= len(s$) then begin
    chr = asc(mid$(s$, txt_k, 1))
    ' print "{x13}";chr$(27);"qchr=";chr;
    gosub petscii_to_screencode
    gosub screencode_to_idx
    ' print "fixed chr=";chr;
    ' get key z$

    if chr=100 then begin
      ' wc_space = 7
      wxx=wxx+6
      txt_k = txt_k + 1
      if scroll_flag then gosub scroll_canvas_right:wxx=wxx-1
    bend:else:begin
      wc_flag = 1
      wc_chr = chr
      pidx%(fidx%) = char_idx%(chr)
    bend
  bend

  if wc_flag = 1 then begin
    chr = wc_chr
    gosub iter_write_char
    if ret = 1 then begin
      ret = 0
      wxx = wxx + char_width%(wc_chr) + 1
      txt_k = txt_k + 1
      if txt_k > len(s$) then ret = 1: s$=""
      wc_flag = 0
    bend
  bend
  return


'----------
.iter_write_char
'---------------
  ' iterate over chars in string
    ' draw current char at given x,y pos
    ' increment x,y location

  ret = 1

  for itercnt = 0 to 3
    if pidx%(fidx%) < didx%(fidx%) and ldata&(fidx%, pidx%(fidx%)) <> $ff then begin

      ' cursor 0,49
      ' print chr$(27);"qpidx=";pidx%(fidx%);"[";ldata&(fidx%, pidx%);
      ' print ldata&(fidx%, pidx%+1);ldata&(fidx%, pidx%+2);

      val& = ldata&(fidx%, pidx%(fidx%))
      pidx%(fidx%) = pidx%(fidx%) + 1

      x = val& and $7f

      if val& and $80 then rev_flag&(fidx%) = 1 : else rev_flag&(fidx%) = 0
      y = ldata&(fidx%, pidx%(fidx%))
      pidx%(fidx%) = pidx%(fidx%) + 1

      a$ = chr$(ldata&(fidx%, pidx%(fidx%)))
      pidx%(fidx%) = pidx%(fidx%) + 1

      dxx = wxx+x : dyy = wyy+y : gosub draw_char

      ' print "{x13}{x11}";chr$(27);"q x,y,pidx,a$=";x;y;pidx%(fidx%),asc(a$)
      ' get key a$
      ret = 0
    bend
  next itercnt

  lyr_t = lyr_t + 1
  if scroll_flag then gosub scroll_canvas_right:wxx=wxx-1

  return



'--------------
.line_file_init
'--------------
  oldx = -1 : oldy = -1 : oldoffs(fidx%) = 0
  didx%(fidx%) = 0
  group_flag& = 0 : rev_flag&(fidx%) = 0
  offs(fidx%) = 0
  return

         
'--------------
.play_data_init
'--------------
  offs(fidx%)=0
  pidx%(fidx%) = 0
  if lastflag = 1 then pidx%(fidx%) = last_group_idx : lastflag = 0
  return

'--------------
.play_data_iter
'--------------
  if pidx%(fidx%) < didx%(fidx%) then begin
    val& = ldata&(fidx%, pidx%(fidx%))
    pidx%(fidx%) = pidx%(fidx%) + 1

    if ver(fidx%)=3 and val& = $ff then begin
      if pidx%(fidx%) > last_group_idx then last_group_idx = pidx%(fidx%)
      goto pd_endloop
    bend

    x = val& and $7f
    if ver(fidx%)=2 then begin
      x = val&
      val& = ldata&(fidx%, pidx%(fidx%))
      pidx%(fidx%) = pidx%(fidx%) + 1
      x = x + (val& and $7f) * 256
    bend

    if val& and $80 then rev_flag&(fidx%) = 1: else rev_flag&(fidx%) = 0
    y = ldata&(fidx%, pidx%(fidx%))
    pidx%(fidx%) = pidx%(fidx%) + 1

    a$ = chr$(ldata&(fidx%, pidx%(fidx%)))
    pidx%(fidx%) = pidx%(fidx%) + 1

    if ver(fidx%)=2 then begin
      if x-offs(fidx%) > 78 then begin
        if scroll_flag then gosub scroll_canvas_right
        pidx%(fidx%) = pidx%(fidx%) - 4
        return
        ' print "{x13}";chr$(27);"qoffs=";offs(fidx%);
      bend
    bend

    dxx = x-offs(fidx%) : dyy = y: gosub draw_char

    debug = 0
    if debug=1 then begin
      print "{x13}{x11}";chr$(27);"q x,y,pidx,a$,offs=";x;y;pidx%(fidx%),asc(a$),offs(fidx%)
      get key a$
    bend

.pd_endloop

  bend

  x = x-offs(fidx%)

  return


'-------------------
.scroll_canvas_right
'-------------------
  offs(fidx%) = offs(fidx%) + 1
  if fidx% = 0 then addr = $20  ' $52000
  if fidx% = 1 then addr = $40  ' $54000
  if fidx% = 2 then addr = $20

  bank 0:sys $7e12, addr: bank 128

  return


'---------
.draw_char
'---------
  ' poke $40800 + x + y*80, asc(a$)
  ' poke $ff80000 + x + y*80, rcolor(1)
  
  chr = asc(a$)
  gosub petscii_to_screencode

  if rev_flag&(fidx%) = 1 then chr = chr + 128

  if ver(fidx%) = 1 or ver(fidx%) = 3 then begin
    poke $52000 + dxx + dyy*80, chr
    poke $53000 + dxx + dyy*80, chrclr
  bend

  if ver(fidx%) = 2 then begin
    poke $54000 + dxx + dyy*80, chr
    poke $55000 + dxx + dyy*80, chrclr
  bend

  return


'---------------------
.petscii_to_screencode
'---------------------
  ' Based on the table here:
  ' https://sta.c64.org/cbm64pettoscr.html
  ' - seems like I needed to do a repair to it on the $a0-->$bf range
  if chr>=$00 and chr<=$1f then chr=chr or $80:return
  if chr>=$20 and chr<=$3f then return
  if chr>=$40 and chr<=$5f then chr=chr and $bf:return
  if chr>=$60 and chr<=$7f then chr=chr and $df:return
  if chr>=$80 and chr<=$9f then chr=chr or $40:return
  if chr>=$a0 and chr<=$bf then chr=(chr and $7f) or $40:return ' $bf:return
  if chr>=$c0 and chr<=$fe then chr=chr and $7f:return
  return


'-----------------
.screencode_to_idx
'-----------------
  if chr >= 65 and chr <= 90 then chr = chr - 65:return
  if chr = 46 then chr = 26:return ' full-stop
  if chr = 33 then chr = 27:return ' exclamation
  if chr = 44 then chr = 28:return ' comma (smiley)
  if chr = 47 then chr = 29:return ' forward slash (love heart)
  if chr = 35 then chr = 30:return ' # hash (dhufish)
  if chr >= 1 and chr <= 26 then chr = chr + 30:return
  if chr = 39 then chr = 57:return
  if chr = 32 then chr = 100:return
  return
ÿ