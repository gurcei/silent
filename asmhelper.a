!to "asmhelper.prg", cbm

// DEFINES
// =======
ZEROPTR = $1c
ONEPTR = $29
FOURPTR = $18
CLRPTR = $20

// for megaplot (some overlap)
COLRBASE = $0000 // Fixed to Bank ff8
ROWPTR = $18
COLPTR = $1c
MULTINA = $d770
MULTINB = $d774
MULTOUT = $d778


// BANK4 VAR INTERFACE
// ===================
DEFAULT_RED = $20
DEFAULT_GREEN = $22
DEFAULT_BLUE = $24
CURR_RED = $26
CURR_GREEN = $28
CURR_BLUE = $2a
DATA_ADDR = $2c	// src of dma
CDATA_ADDR = $2e
SCRADDR = $30	// dest of dma
CLRADDR = $32
INC_FRM = $34
STARX = $36
STARVX = $38

MULTINA = $d770
MULTINB = $d774
MULTOUT = $d778


// MACROS
// ======
!macro copy16 .dest, .src {
	lda .src
	sta .dest
	lda .src+1
	sta .dest+1
}

!macro set16 .dest, .val {
	lda #<.val
	sta .dest
	lda #>.val
	sta .dest+1
}

!macro lsr16 .loc {
	clc
	lda .loc+1
	ror
	sta .loc+1
	lda .loc
	ror
	sta .loc
}

!macro lsr16_by .loc, .cnt {
	ldx #.cnt
	cpx #$00
	beq +
-	+lsr16 .loc
	dex
	bne -
+ 
}

!macro copy_basic_int .bk4loc, .out {
	+set0ptr_from_4ptr .bk4loc
	ldz #$00
	lda [ZEROPTR],z
	sta .out+1
	inz
	lda [ZEROPTR],z
	sta .out
}

!macro set0ptr_from_4ptr .b4offs {
	phz
	ldz #.b4offs
	lda [FOURPTR],z
	sta ZEROPTR
	inz
	lda [FOURPTR],z
	sta ZEROPTR+1
	plz
}

!macro set1ptr_from_4ptr .b4offs {
	phz
	ldz #.b4offs
	lda [FOURPTR],z
	sta ONEPTR
	inz
	lda [FOURPTR],z
	sta ONEPTR+1
	plz
}

!macro add16 .in1, .in2, .out {
	clc
	lda .in1
	adc .in2
	sta .out
	lda .in1+1
	adc .in2+1
	sta .out+1
	clc
}

!macro subtract16 .in1, .in2, .out {
	sec
	lda .in1
	sbc .in2
	sta .out
	lda .in1+1
	sbc .in2+1
	sta .out+1
	clc
}

!macro multiply16 .in1, .in2, .out {
	phz
	ldz #$00
	ldy #$00
	ldx .in1+1
	lda .in1
	stq MULTINA

	ldx .in2+1
	lda .in2
	stq MULTINB

	ldq MULTOUT
	stx .out
	sty .out+1
	plz
}

!macro multiply8 .in1, .in2, .out {
	phz
	ldz #$00
	ldy #$00
	ldx #$00
	lda .in1
	stq MULTINA

	lda .in2
	stq MULTINB

	ldq MULTOUT
	stx .out+1
	sta .out
	plz
}

!macro wpoke_b4 .offs, .intvar {
	ldz#.offs
	lda .intvar
	sta [FOURPTR],z
	inz
	lda .intvar+1
	sta [FOURPTR],z
}

!macro poke_b4 .offs, .bytevar {
	ldz#.offs
	lda .bytevar
	sta [FOURPTR],z
}

!macro poke_b4_val .offs, .byte {
	ldz#.offs
	lda#.byte
	sta [FOURPTR],z
}

!macro fade_clr1_to_white_step .bk4ptr, .palette_loc {
	// flip_var = default_red&(k)
	+set1ptr_from_4ptr .bk4ptr
	lda [ONEPTR],z

	// gosub flip_nibble
	jsr flip_nibble

	// clr1 = flip_var
	sta clr1+1
	lda #$00
	sta clr1
	
	// clr2 = $f0   ' (white)
	sta clr2
	lda #$f0
	sta clr2+1
	
	jsr calc_faded_colour

	// poke $d100+k, flip_var
	phz
	plx
	sta .palette_loc,x
}

!macro fade_clr1_to_black_step .bk4ptr, .palette_loc {
	// flip_var = default_red&(k)
	+set1ptr_from_4ptr .bk4ptr
	lda [ONEPTR],z

	// gosub flip_nibble
	jsr flip_nibble

	// clr1 = flip_var
	sta clr1+1
	lda #$00
	sta clr1
	
	// clr2 = $00   ' (black)
	sta clr2
	sta clr2+1
	
	jsr calc_faded_colour

	// poke $d100+k, flip_var
	phz
	plx
	sta .palette_loc,x
}

!macro fade_clr1_to_clr2_step .bk4ptr1, .bk4ptr2, .palette_loc {
	// flip_var = curr_red&(k)
	+set1ptr_from_4ptr .bk4ptr1
	lda [ONEPTR],z

	// gosub flip_nibble
	jsr flip_nibble

	// clr1 = flip_var
	sta clr1+1
	lda #$00
	sta clr1
	
	// flip_var = default_red&(k)
	+set1ptr_from_4ptr .bk4ptr2
	lda [ONEPTR],z

	// gosub flip_nibble
	jsr flip_nibble

	// clr2 = flip_var
	sta clr2+1
	lda #$00
	sta clr2
	
	jsr calc_faded_colour

	// poke $d100+k, flip_var
	phz
	plx
	sta .palette_loc,x
}

// ROUTINES
// ========
* = $7e00
	jmp fade_colours_to_white	// 7e00
	jmp fade_between_colours	// 7e03
	jmp cycle_alt_palette		// 7e06
	jmp draw_petscii_frame		// 7e09
	jmp fade_colours_to_black	// 7e0c
	jmp iter_starfield		// 7e0f
	jmp scroll_canvas_right		// 7e12
	jmp page_flip			// 7e15
	// megaplot routines
	// -----------------
	jmp init_and_plot		// 7e18
	jmp init			// 7e1b
	jmp plot			// 7e1e
	jmp line			// 7e21
	jmp set_colour			// 7e24


//---------------------
fade_colours_to_white: // (a=fadeval)
//---------------------
	//sei
	// store a into fadeval
	sta fadeval+1
	lda #$00
	sta fadeval

	// prepare four pointer
	lda #$00
	sta FOURPTR
	sta FOURPTR+1
	sta FOURPTR+3
	lda #$04
	sta FOURPTR+2

	// INPUT: fadeval=0 to 128
	// tempval = fadeval / 128
	+copy16 tempval, fadeval
	+lsr16_by tempval, 7

	//for k = 0 to 31
	ldz #$00

-		+fade_clr1_to_white_step DEFAULT_RED, $d100
		+fade_clr1_to_white_step DEFAULT_GREEN, $d200
		+fade_clr1_to_white_step DEFAULT_BLUE, $d300

	//next k
	inz
	cpz #32
	lbne -

	// return
	cli
	rts


//---------------------
fade_between_colours: // (a=fadeval)
//---------------------
	//sei
	// store a into fadeval
	sta fadeval+1
	lda #$00
	sta fadeval

	// prepare four pointer
	lda #$00
	sta FOURPTR
	sta FOURPTR+1
	sta FOURPTR+3
	lda #$04
	sta FOURPTR+2

	// INPUT: fadeval=0 to 128
	// tempval = fadeval / 128
	+copy16 tempval, fadeval
	+lsr16_by tempval, 7

	//for k = 0 to 31
	ldz #$00

kloop:
		+fade_clr1_to_clr2_step CURR_RED, DEFAULT_RED, $d100
red:
		+fade_clr1_to_clr2_step CURR_GREEN, DEFAULT_GREEN, $d200
green:
		+fade_clr1_to_clr2_step CURR_BLUE, DEFAULT_BLUE, $d300
blue:

	//next k
	inz
	cpz #32
	lbne kloop

	// return
	cli
	rts


//---------------
cycle_alt_palette:
//---------------  // a = base colour to start from (e.g. y=12 means cycle from 12 to 31(
	tay

	// prepare four pointer
	lda #$00
	sta FOURPTR
	sta FOURPTR+1
	sta FOURPTR+3
	lda #$04
	sta FOURPTR+2

	// tempr = peek($d100+12)
	lda $d100,y
	sta tempr
	// tempg = peek($d200+12)
	lda $d200,y
	sta tempg
	// tempb = peek($d300+12)
	lda $d300,y
	sta tempb

	// for k = 12 to 30
	tya
	tax
		// poke $d100+k, peek($d100+k+1)
-		lda $d101,x
		sta $d100,x
		// poke $d200+k, peek($d200+k+1)
		lda $d201,x
		sta $d200,x
		// poke $d300+k, peek($d300+k+1)
		lda $d301,x
		sta $d300,x
	// next k
	inx
	cpx #31
	bne -

	// poke $d100+31, tempr
	lda tempr
	sta $d100+31
	// poke $d200+31, tempg
	lda tempg
	sta $d200+31
	// poke $d300+31, tempb
	lda tempb
	sta $d300+31
	
	// ----------------------------

do_curr:
	tya
	taz
	// tempr = curr_red&(12)
	+set1ptr_from_4ptr CURR_RED
	lda [ONEPTR],z
	sta tempr
	// tempg = curr_green&(12)
	+set1ptr_from_4ptr CURR_GREEN
	lda [ONEPTR],z
	sta tempg
	// tempb = curr_blue&(12)
	+set1ptr_from_4ptr CURR_BLUE
	lda [ONEPTR],z
	sta tempb

	// for k = 12 to 30
	tya
	taz
		// curr_red&(k) = curr_red&(k+1)
-		+set1ptr_from_4ptr CURR_RED
		inz
		lda [ONEPTR],z
		dez
		sta [ONEPTR],z
		// curr_green&(k) = curr_green&(k+1)
		+set1ptr_from_4ptr CURR_GREEN
		inz
		lda [ONEPTR],z
		dez
		sta [ONEPTR],z
		// curr_blue&(k) = curr_blue&(k+1)
		+set1ptr_from_4ptr CURR_BLUE
		inz
		lda [ONEPTR],z
		dez
		sta [ONEPTR],z
	// next k
	inz
	cpz #31
	bne -

	ldz #31
	// curr_red&(31) = tempr
	+set1ptr_from_4ptr CURR_RED
	lda tempr
	sta [ONEPTR],z
	// curr_green&(31) = tempg
	+set1ptr_from_4ptr CURR_GREEN
	lda tempg
	sta [ONEPTR],z
	// curr_blue&(31) = tempb
	+set1ptr_from_4ptr CURR_BLUE
	lda tempb
	sta [ONEPTR],z
	
	// ----------------------------

do_default:
	tya
	taz
	// tempr = default_red&(12)
	+set1ptr_from_4ptr DEFAULT_RED
	lda [ONEPTR],z
	sta tempr
	// tempg = default_green&(12)
	+set1ptr_from_4ptr DEFAULT_GREEN
	lda [ONEPTR],z
	sta tempg
	// tempb = default_blue&(12)
	+set1ptr_from_4ptr DEFAULT_BLUE
	lda [ONEPTR],z
	sta tempb

	// for k = 12 to 30
	tya
	taz
		// default_red&(k) = default_red&(k+1)
-		+set1ptr_from_4ptr DEFAULT_RED
		inz
		lda [ONEPTR],z
		dez
		sta [ONEPTR],z
		// default_green&(k) = default_green&(k+1)
		+set1ptr_from_4ptr DEFAULT_GREEN
		inz
		lda [ONEPTR],z
		dez
		sta [ONEPTR],z
		// default_blue&(k) = default_blue&(k+1)
		+set1ptr_from_4ptr DEFAULT_BLUE
		inz
		lda [ONEPTR],z
		dez
		sta [ONEPTR],z
	// next k
	inz
	cpz #31
	bne -

	ldz #31
	// default_red&(31) = tempr
	+set1ptr_from_4ptr DEFAULT_RED
	lda tempr
	sta [ONEPTR],z
	// default_green&(31) = tempg
	+set1ptr_from_4ptr DEFAULT_GREEN
	lda tempg
	sta [ONEPTR],z
	// default_blue&(31) = tempb
	+set1ptr_from_4ptr DEFAULT_BLUE
	lda tempb
	sta [ONEPTR],z

	//return
	rts


//------
draw_petscii_frame: // (a = frmy, x = frmy1, y = frmw)
//------
// input: word data_addr (always bank 4)
// input: word cdata_addr (always bank 4)
// input: word scraddr (always bank 5)
// input: word clraddr (always bank 5)

	// save passed regs
	sta frmy+1
	lda #$00
	sta frmy

	stx frmy1+1
	sta frmy1

	sty frmw

	// prepare zero pointer
	lda #$00
	sta ZEROPTR
	sta ZEROPTR+1
	sta ZEROPTR+2
	sta ZEROPTR+3

	sta FOURPTR
	sta FOURPTR+1
	sta FOURPTR+3
	lda #$04
	sta FOURPTR+2

	sta CLRPTR
	sta CLRPTR+1
	lda #$f8
	sta CLRPTR+2
	lda #$0f
	sta CLRPTR+3

	+copy_basic_int DATA_ADDR, data_addr
	+copy_basic_int CDATA_ADDR, cdata_addr
	+copy_basic_int SCRADDR, scraddr
	+copy_basic_int CLRADDR, clraddr
	+copy_basic_int INC_FRM, inc_frm

	// for yy=frmy1 to frmy step -inc(frameidx)
	+copy16 yy, frmy1
	
foryyloop:
		//if scraddr < 0 then goto for_skip
		lda scraddr+1
		bpl +
		rts

		// if yy < frmy then yy = frmy
+               lda yy+1
		cmp frmy+1
		bmi force_yy // if hi(yy) < hi(frmy)
		bne +   // jump if hi(yy) > hi(frmy)

		lda yy
		cmp frmy
		bpl +

force_yy:
		+copy16 yy, frmy
		
		// ' draw chars
		// ' ----------
		// src_addr = data_addr + int(yy-frmy) * frmw
+ 		lda #$00
		sta tmpw+1
		sec
		lda yy+1
		sbc frmy+1
		sta tmpw	// tmpw = int(yy-frmy)

		+multiply8 tmpw, frmw, tmpw		// tmpw = frmw * tmpw
		+add16 data_addr, tmpw, src_addr	// src_addr = data_addr + tmpw

		// dest_addr = scraddr
		+copy16 dest_addr, scraddr

		// length = frmw
		lda frmw
		sta length
		lda #$00
		sta length+1

		// transp = 102
		lda #102
		sta transp

		// gosub transparent_dma
		jsr transparent_dma
		
		// src_addr = cdata_addr + int(yy-frmy) * frmw
		+add16 cdata_addr, tmpw, src_addr	// src_addr = cdata_addr + tmpw

		// dest_addr = clraddr
		+copy16 dest_addr, clraddr

		//length = frmw
		lda frmw
		sta length
		lda #$00
		sta length+1

		// transp = $ff
		lda #$ff
		sta transp

		// gosub transparent_dma
		jsr transparent_dma
		
		lda #80
		sta tmpw
		lda #$00
		sta tmpw+1
		// scraddr = scraddr - 80
		+subtract16 scraddr, tmpw, scraddr

		// clraddr = clraddr - 80
		+subtract16 clraddr, tmpw, clraddr

	// next yy
	// for yy=frmy1 to frmy step -inc(frameidx)
	// if yy == frmy1 then exit
	lda yy
	cmp frmy
	bne nextlp

	lda yy+1
	cmp frmy+1
	bne nextlp
	rts

nextlp:
	+subtract16 yy, inc_frm, yy

	jmp foryyloop
	
	// return
	rts


//---------------------
fade_colours_to_black: // (a=fadeval)
//---------------------
	//sei
	// store a into fadeval
	sta fadeval+1
	lda #$00
	sta fadeval

	// prepare four pointer
	lda #$00
	sta FOURPTR
	sta FOURPTR+1
	sta FOURPTR+3
	lda #$04
	sta FOURPTR+2

	// INPUT: fadeval=0 to 128
	// tempval = fadeval / 128
	+copy16 tempval, fadeval
	+lsr16_by tempval, 7

	//for k = 0 to 31
	ldz #$00

-		+fade_clr1_to_black_step DEFAULT_RED, $d100
		+fade_clr1_to_black_step DEFAULT_GREEN, $d200
		+fade_clr1_to_black_step DEFAULT_BLUE, $d300

	//next k
	inz
	cpz #32
	lbne -

	// return
	cli
	rts


//------------
iter_starfield:
//------------
	// prepare four pointer
	lda #$00
	sta FOURPTR
	sta FOURPTR+1
	sta FOURPTR+3
	lda #$04
	sta FOURPTR+2

	// prepare zero pointer
	lda #$00
	sta ZEROPTR
	sta ZEROPTR+1
	sta ZEROPTR+2
	sta ZEROPTR+3

	+set1ptr_from_4ptr STARX
	ldz #$00

	+set0ptr_from_4ptr STARVX
	lda #$01	// switch it to a 1 pointer too, just for convenience
	sta ZEROPTR+2
	lda #$00
	sta ZEROPTR+3

	// for k = 0 to 20
	ldy #$00

		// starx(k) = mod(starx(k) - starvx(k) +80, 80)
-		sec
		inz
		lda [ONEPTR],z
		sbc [ZEROPTR],z
		sta [ONEPTR],z
		dez
		lda [ONEPTR],z
		sbc [ZEROPTR],z
		sta [ONEPTR],z

		bpl +		// check if subtraction was negative

		clc		// if negative, add 80
		adc #80
		sta [ONEPTR],z
		clc

+
		inz
		inz

	// next k
	iny
	cpy #21
	bne -

	rts


//-------------------
scroll_canvas_right: // (a = hi_addr)
//-------------------
	// offs(fidx%) = offs(fidx%) + 1
	// if fidx% = 0 then addr = $52000
	// if fidx% = 1 then addr = $54000

	sta data_addr+1
	lda #$00
	sta data_addr

	lda #79
	sta frmw
	+set16 length, 79

	lda #$00
	sta tmpw
	sta tmpw+1

	// prepare four pointer
	lda #$00
	sta FOURPTR
	sta FOURPTR+1
	sta FOURPTR+3
	lda #$04
	sta FOURPTR+2

	// prepare ZERO pointer as five pointer
	lda #$00
	sta ZEROPTR
	sta ZEROPTR+1
	sta ZEROPTR+3
	lda #$05
	sta ZEROPTR+2

	// for yy = 0 to 49
	ldy #$00

		// edma OP_COPY, 79, addr+1 + yy*80, addr + yy*80
-		+add16 data_addr, tmpw, dest_addr
		+copy16 src_addr, dest_addr
		clc
		lda src_addr
		adc #$01
		sta src_addr
		lda src_addr+1
		adc #$00
		sta src_addr+1

		jsr plain_dma

		// poke addr + 79 + yy*80, 32 
		lda dest_addr
		sta ZEROPTR
		lda dest_addr+1
		sta ZEROPTR+1
		ldz #79
		lda #32
		sta [ZEROPTR],z

		// edma OP_COPY, 79, addr+$1001 + yy*80, addr+$1000 + yy*80
		clc
		lda src_addr+1
		adc #$10
		sta src_addr+1

		clc
		lda dest_addr+1
		adc #$10
		sta dest_addr+1
		
		jsr plain_dma

		// poke addr+$1000 + 79 + yy*80, 0
		lda dest_addr
		sta ZEROPTR
		lda dest_addr+1
		sta ZEROPTR+1
		ldz #79
		lda #$00
		sta [ZEROPTR],z

		clc
		lda tmpw
		adc #80
		sta tmpw
		lda tmpw+1
		adc #$00
		sta tmpw+1
		
	// next yy                
	iny
	cpy #50
	lbne -
	
	// return
	rts


//---------
page_flip:
//---------
	// prepare four pointer
	lda #$00
	sta FOURPTR
	sta FOURPTR+1
	sta FOURPTR+3
	lda #$04
	sta FOURPTR+2

	+poke_b4_val $0b, 5	// src bank
	+poke_b4_val $0e, 5	// dest bank

	// src_addr = $54000
	+set16 src_addr, $4000

	// dest_addr = $50000
	+set16 dest_addr, $0000

	// length = 4000
	+set16 length, 4000

	// transp = 32
	lda #32
	sta transp

	// gosub transparent_dma
	jsr transparent_dma

	// src_addr = $55000
	+set16 src_addr, $5000

	// dest_addr = $51000
	+set16 dest_addr, $1000

	// length = 4000
	// transp = 0
	lda #$00
	sta transp

	// gosub transparent_dma
	jsr transparent_dma

	// src_addr = $52000
	+set16 src_addr, $2000

	// dest_addr = $50000
	+set16 dest_addr, $0000

	// length = 4000
	// transp = 32
	lda #32
	sta transp

	// gosub transparent_dma
	jsr transparent_dma

	// src_addr = $53000
	+set16 src_addr, $3000

	// dest_addr = $51000
	+set16 dest_addr, $1000

	// length = 4000
	// transp = 0
	lda #$00
	sta transp

	// gosub transparent_dma
	jsr transparent_dma

	// edma 0, $fa0, $50000, $40800
	+poke_b4_val $0b, 5	// src bank
	+poke_b4_val $0e, 4	// dest bank
	+set16 length, $fa0
	+set16 src_addr, $0000
	+set16 dest_addr, $0800

	jsr plain_dma

	// edma 0, $fa0, $51000, $ff80000
	+poke_b4_val $01, $ff	// dest MB
	+poke_b4_val $02, $06	// disable transparency

	+poke_b4_val $0b, 5		// src bank
	+poke_b4_val $0e, $08	// dest bank

	+set16 src_addr, $1000
	+set16 dest_addr, $0000

	jsr transparent_dma

	+poke_b4_val $01, $00	// dest MB
	+poke_b4_val $02, $07	// enable transparency

	// ' clear the offscreen buffer
	// edma 3, $fa0, 32, $50000
	+poke_b4_val $06, $03	// CMD lsb = FILL
	+poke_b4_val $0e, 5	// dest bank
	+set16 src_addr, 32	// fill value
	+set16 dest_addr, $0000

	jsr plain_dma

	// edma 3, $fa0, 1, $51000
	+set16 src_addr, 1	// fill value
	+set16 dest_addr, $1000

	jsr plain_dma
	
	// restore
	+poke_b4_val $06, $00	// CMD lsb = COPY
	+poke_b4_val $0b, 5	// src bank

	// return
	rts


//-----------
init_and_plot:
//-----------
				pha
				phx
				phy
				jsr init
				ply
				plx
				pla

				jsr plot
				rts


//---
init:
//---
// populate properties and initialise
				// 40 or 80 column screen?
				lda #80
				sta xmode4080
				lda $d031
				and #$80
				bne +
				lda #40
				sta xmode4080

				
+				// 25 or 50 row screen?
				lda #50
				sta ymode2550
				lda $d031
				and #$08
				bne +
				lda #25
				sta ymode2550

				jsr init2

+				rts


//---
plot:
//---
				sta xpos
				stx ypos
				sty colour

_plot:
				jsr init2

__plot:
				jsr check_xy_in_range
				bcc +
				rts

+				jsr find_char_positions	// sets screenx, screeny,
										// xhalf and yhalf (if odd, set to $ff, if even, set to $00)


				jsr which_char_at_xy 	// for given x,y, existing battenburg char is stored in 'virtual'
										// (if one exists, otherwise, virtual = 0)

				jsr update_char_at_xy	// based on xhalf,yhalf, decide which battenburg pixel to update

				rts


//---
line:
//---
	//sei
	pha
	lda #$00
	sta x1+1
	sta y1+1
	sta x2+1
	sta y2+1
	pla
	
	sta x1
	cmp #160
	bcc +
	lda #$ff
	sta x1+1

+	stx y1
	txa
	bpl +
	lda #$ff
	sta y1+1

+	sty x2
	tya
	cmp #160
	bcc +
	lda #$ff
	sta x2+1

+	stz y2
	tza
	bpl +
	lda #$ff
	sta y2+1

+	jsr init

	// borrowed from: www.baeldung.com/cs/bresenhams-line-algorithm
	lda #$01
	sta sx
	lda #$00
	sta sx+1
	lda #$ff
	sta sy
	sta sy+1

	// ddx = abs(x2-x1)
	lda x2
	sec
	sbc x1
	sta ddx

	lda x2+1
	sbc x1+1
	sta ddx+1

	bpl +

	lda ddx
	eor #$ff
	clc
	adc #$01
	sta ddx

	lda ddx+1
	eor #$ff
	adc #$00
	sta ddx+1

	// if x1 < x2 then sx = 1 : else sx = -1
	lda #$ff
	sta sx
	sta sx+1
	
	// ddy = -abs(y2-y1)
+	lda y2
	sec
	sbc y1
	sta ddy

	lda y2+1
	sbc y1+1
	sta ddy+1

	bmi +

	lda ddy
	eor #$ff
	clc
	adc #$01
	sta ddy

	lda ddy+1
	eor #$ff
	adc #$00
	sta ddy+1

	// if y1 < y2 then sy = 1 : else sy = -1
	lda #$01
	sta sy
	lda #$00
	sta sy+1
	
	// _e = ddx + ddy
+	lda ddx
	clc
	adc ddy
	sta _e

	lda ddx+1
	adc ddy+1
	sta _e+1
	
	// xpos = x1 : ypos = y1
	lda x1
	sta xpos
	lda x1+1
	sta xpos+1

	lda y1
	sta ypos
	lda y1+1
	sta ypos+1

	lda #$00
	sta virtual
	sta xhalf
	sta yhalf

	// do while 1
pixel_loop:
				lda #$00
				sta virtual
				sta xhalf
				sta yhalf
				sta COLPTR + 3
				sta ROWPTR + 3
				lda #$05
				sta COLPTR + 2
				sta ROWPTR + 2

		// gosub draw_pixel
		jsr __plot

		//if xpos = (x2) and ypos = y2 then exit
		lda xpos
		cmp x2
		bne +
		lda xpos+1
		cmp x2+1
		bne +

		lda ypos
		cmp y2
		bne +
		lda ypos+1
		cmp y2+1
		bne +

		cli
		rts
	
		// _e2 = 2 * _e
+ 		lda _e
		clc
		rol
		sta _e2
		lda _e+1
		rol
		sta _e2+1

		// if _e2 >= ddy then begin
		sec
		lda _e2
		sbc ddy
		sta tmpw
		lda _e2+1
		sbc ddy+1
		sta tmpw+1

		bmi ++

			// if xpos = x2 then exit
+			lda xpos
			cmp x2
			bne +
			lda xpos+1
			cmp x2+1
			bne +
			cli
			rts

			// _e = _e + ddy
+			clc
			lda _e
			adc ddy
			sta _e
			lda _e+1
			adc ddy+1
			sta _e+1

			// xpos = xpos + sx
			clc
			lda xpos
			adc sx
			sta xpos
			lda xpos+1
			adc sx+1
			sta xpos+1
		// bend


		// if _e2 <= ddx then begin
++		sec
		lda _e2
		sbc ddx
		sta tmpw
		lda _e2+1
		sbc ddx+1
		sta tmpw+1

		bmi +
		ora tmpw
		beq +

		jmp pixel_loop

+			// if ypos = y2 then exit
			lda ypos
			cmp y2
			bne +

			lda ypos+1
			cmp y2+1
			bne +

			cli
			rts

			// _e = _e + ddx
+			clc
			lda _e
			adc ddx
			sta _e
			lda _e+1
			adc ddx+1
			sta _e+1

			// ypos = ypos + sy
			clc
			lda ypos
			adc sy
			sta ypos
			lda ypos+1
			adc sy+1
			sta ypos+1
		// bend
	
	// loop
+	jmp pixel_loop

	cli
	rts


//-------
set_colour:
//-------
	sta colour
	rts


// ---------------------
// INTERNAL ASM ROUTINES
// ---------------------

transparent_dma:
//-------------
	// wpoke $40009, src_addr
	+wpoke_b4 $09, src_addr

	// wpoke $4000c, dest_addr
	+wpoke_b4 $0c, dest_addr

	// wpoke $40007, length
	+wpoke_b4 $07, length

	// poke  $40004, transp
	+poke_b4 $04, transp

	// poke $d702, 4 ' dma list in bank 4
	lda #$04
	sta $d702

	// poke $d701, $00 ' dma list msb
	lda #$00
	sta $d701

	// poke $d705, $00 ' dma list lsb
	lda #$00
	sta $d705
	
	// return
	rts


plain_dma:
//--
	// wpoke $40009, src_addr
	+wpoke_b4 $09, src_addr

	// wpoke $4000c, dest_addr
	+wpoke_b4 $0c, dest_addr

	// wpoke $40007, length
	+wpoke_b4 $07, length

	// poke $d702, 4 ' dma list in bank 4
	lda #$04
	sta $d702

	// poke $d701, $00 ' dma list msb
	lda #$00
	sta $d701

	// poke $d705, $00 ' dma list lsb
	lda #$05
	sta $d705
	
	// return
	rts

flip_nibble:
// --------
	clc
	tax
	and #$0f
	asl
	asl
	asl
	asl
	sta tmp

	txa
	and #$f0
	lsr
	lsr
	lsr
	lsr

	ora tmp
	rts


calc_faded_colour:
//----------------
	// flip_var = clr1 + (clr2 - clr1) * tempval
	lda clr2+1
	cmp clr1+1
	bcc +		// clr1 > clr2?

	+subtract16 clr2, clr1, tmpw
	+multiply16 tmpw, tempval, tmpw
	+add16 clr1, tmpw, tmpw
	jmp ++

+	+subtract16 clr1, clr2, tmpw
	+multiply16 tmpw, tempval, tmpw
	+subtract16 clr1, tmpw, tmpw

++
	// gosub flip_nibble
	lda tmpw+1
	jsr flip_nibble
	
	rts


//----
init2:
//----
				lda #$00
				sta virtual
				sta xhalf
				sta yhalf

				// init high word of COLPTR to be $0ff8
				lda #$00
				sta COLPTR + 3
				lda #$05
				sta COLPTR + 2

				// init high word of ROWPTR to be LO=SCRNPTRBNK($D062) HI=SCRNPTRMB($D063.0-3)
				lda #$00
				sta ROWPTR + 3
				lda #$05
				sta ROWPTR + 2

				rts


//---------------
update_char_at_xy:
//---------------
				// if on left, bits 1 or 3
				lda xhalf
				bne SetRightBit  // plot must be on the right of the battenburg
				// since bits 1 or 3 is set, we are on the left - top left or bottom left?
				lda yhalf
				beq SetTopLeft
				ldx #$04 // bottom left
				jmp Combine
SetTopLeft:		ldx #$01 // top left	
				jmp Combine

SetRightBit:	lda yhalf
				beq SetTopRight
				ldx #$08
				jmp Combine
SetTopRight:	ldx #$02

Combine:		// combine the new bit with those of any pre-existing bits 
				txa
				ora virtual
				tax

				// What's the character corresponding to the combined bit pattern?
NextCharOut:	lda bitpatterns,x
				
Plot:			phy
				plz
				sta [ROWPTR],z
				lda colour
				sta [COLPTR],z

DumpReg:		ldx ROWPTR
				ldy ROWPTR + 1
				ldz xhalf
				rts

//---------------
check_xy_in_range:
//---------------
				// don't draw negative x
				lda xpos
				cmp #160
				bcc +
				sec
				rts

				// don't draw negative y
+				lda ypos
				bpl +
				sec
				rts

+				lda xmode4080
				cmp #80
				beq ValidateX80

ValidateX40:	lda xpos 
				cmp #80
				bcc xok
				sec
				rts // if out of range, don't draw

				// validate values
ValidateX80:		lda xpos
				cmp #160
				bcc xok
				sec
				rts	// if out of range, don't draw

xok:			lda ymode2550
				cmp #50
				beq ValidateY50

ValidateY25:	lda ypos
				cmp#50
				bcc yok
				sec
				rts // if out of range, don't draw

ValidateY50:	lda ypos
				cmp#100
				bcc yok
				sec
				rts // if out of range, don't draw

yok:			clc
				rts


//-----------------
find_char_positions:
//-----------------
				// find character positions
				//divide x by 2
				clc
				lda xpos
				ror
				sta screenx
				// is it an odd number?  Then we need a right half pixel to be set
				bcc +
				lda #$ff
				sta xhalf

				//divide y by 2
+				clc
				lda ypos
				ror
				sta screeny
				// is it an odd number?  Then we need a bottom half pixel to be set
				bcc +
				lda #$ff
				sta yhalf

+				rts




//-------------------------------
update_pointers_to_start_of_y_row:
//-------------------------------
				ldz #$00
				ldy #$00
				ldx #$00
				lda screeny
				stq MULTINA

				lda xmode4080
				stq MULTINB

				ldq MULTOUT

				clc
				tay
				adc ROWPTR
				sta ROWPTR

				txa
				adc ROWPTR+1
				sta ROWPTR+1

				clc
				tya
				adc COLPTR
				sta COLPTR

				txa
				adc COLPTR+1
				sta COLPTR+1

+				rts


//--------------------------------
check_for_battenburg_char_at_x_col:
//--------------------------------
				// z is the x coordinate to print to
				ldy screenx
				ldz screenx
				lda [COLPTR],z
				cmp colour
				beq CheckChar

				ldx #$00
				stx virtual

				rts

				// Is there already a plot character in the box?
CheckChar:		// Is it in the list?  If so, which bit pattern?
				ldx #$00
NextChar:		lda bitpatterns,x
				cmp [ROWPTR],z
				beq CheckDone
				inx
				cpx #$10
				bne NextChar

CheckDone:		// if we reach the end of the list there isn't a battenburg so just go ahead and plot
				cpx #$10
				beq +

				// there is already a plot point in the character square, store its nybble representation
				stx virtual

+				rts


//--------------
which_char_at_xy:
//--------------
				lda #$00
				sta virtual

				// jsr init_screen_and_colour_pointers
				sta ROWPTR
				sta ROWPTR + 1
				sta COLPTR
				ldy #$10
				sty COLPTR + 1
			
				jsr update_pointers_to_start_of_y_row

				jsr check_for_battenburg_char_at_x_col	// if exists, screen-code char stored in 'virtual'

				rts




// VARIABLES
// ---------
fadeval:	!word $00
tempval:	!word $00
clr1:		!word $00
clr2:		!word $00
tmp:		!byte $00
tmpw:		!word $00
tempr:		!byte $00
tempg:		!byte $00
tempb:		!byte $00
data_addr:	!word $00
cdata_addr:	!word $00
scraddr:	!word $00
clraddr:	!word $00
inc_frm:	!word $00
frmy:		!word $00
frmy1:		!word $00
frmw:		!byte $00
yy:		!word $00
src_addr:	!word $00
dest_addr:	!word $00
length:		!word $00
transp:		!byte $00
starx:		!word $00
starvx:		!word $00

// megaplot vars
xmode4080:	!byte 80
ymode2550:	!byte 50
xpos:		!word $00
ypos:		!word $00
colour:		!byte $00
x1:		!word $00
y1:		!word $00
x2:		!word $00
y2:		!word $00
ddx:		!word $00
ddy:		!word $00
sx:		!word $00
sy:		!word $00
_e:		!word $00
_e2:		!word $00
virtual:	!byte $00
xhalf:		!byte $00 // ff if the point is on the right of the character square
yhalf:		!byte $00 // ff if the point is on the bottom of the character square
bitpatterns:	!byte $20,$7e,$7c,$e2,$7b,$61,$ff,$ec,$6c,$7f,$e1,$fb,$62,$fc,$fe,$a0
// descriptions:      spc, TL, TR, hT, BL, vL,  /,iBR, BR,  \, vR,iBL, hB,iTR,iTL,all
screenx:	!byte $00
screeny:	!byte $00
