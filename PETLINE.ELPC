#output "petline"

' draw lines in 80x50 with petscii block chars
' giving a full resolution of 160x100

' NOTE: When I later want to move the logic into assembly,
' consider referencing grim fandango's MEGAPLOT assembly source:
' - https://github.com/grim-fandango/megaplot/blob/master/megaplot.a


'--------
.declares
'--------
#declare PIX_TL = 126
#declare PIX_TR = 124
#declare PIX_BL = 123
#declare PIX_BR = 108

#declare PIX_INV_TL = 254
#declare PIX_INV_TR = 252
#declare PIX_INV_BL = 251
#declare PIX_INV_BR = 236

#declare PIX_DIAG_TL_BR = 127
#declare PIX_DIAG_BL_TR = 255

#declare PIX_HLINE_BOT = 98
#declare PIX_HLINE_TOP = 226

#declare PIX_VLINE_LEFT = 97
#declare PIX_VLINE_RIGHT = 225

#declare PIX_NONE = 32
#declare PIX_ALL = 160

#declare PI = 3.141592654269

'----
.vars
'----
#declare x1, y1, x2, y2
#declare dx, dy, mx, my, cx, cy
#declare cur_char, pix
#declare diffx, diffy, deltax, deltay, tanval, angle
#declare a$, ang, line_length, k, debug
#declare centrex, centrey, centrez
#declare px(10), py(10), plen, pang, pidx, pdist
#declare sqang
#declare cb_anga, cb_angb, cbidx, cbtmp, pz
#declare cb_inca, cb_incb, ret_ang, z$, zfact
#declare ddx, ddy, sx, sy, e, e2

#declare qlidx, qlcnt
#declare qlx1(10), qly1(10), qlx2(10), qly2(10), qlx3(10), qly3(10)
#declare qlvx1, qlvy1, qlvx2, qlvy2
#declare qlclr(10), qlcurclr, kk, t


gosub init

'----
.main
'----
  print "{x93}";
  print "petline example menu:"
  print "--------------------"
  print "1) lines"
  print "2) square"
  print "3) many squares"
  print "4) draw cube"
  print "5) draw many cubes"
  print "6) qix lines"
  print "7) qix triangles"

  get key z$
  if z$="1" then gosub draw_lines_from_centre_out
  if z$="2" then gosub draw_square
  if z$="3" then gosub draw_many_squares
  if z$="4" then gosub draw_cube
  if z$="5" then gosub draw_many_cubes
  if z$="6" then gosub draw_qix_lines
  if z$="7" then gosub draw_qix_triangles

  if z$>="1" and z$<="5" then get key z$
  goto main
  end


'--------------
.draw_qix_lines
'--------------

  ' init
  qlidx = 0 : qlcnt = 0

  qlx1(qlidx) = int(rnd(1)*160)
  qly1(qlidx) = int(rnd(1)*100)

  qlx2(qlidx) = int(rnd(1)*160)
  qly2(qlidx) = int(rnd(1)*100)
  qlcnt = qlcnt + 1

  qlvx1 = rnd(1)*3 + .5
  qlvy1 = rnd(1)*3 + .5
  qlvx2 = rnd(1)*3 + .5
  qlvy2 = rnd(1)*3 + .5

  qlcurclr = mod(qlcurclr + 1, 16)
  qlclr(qlidx) = qlcurclr

.qll_loop
  vsync 0
  print "{x93}";

  for k = 0 to qlcnt - 1
    kk = mod(qlidx + k, 10)

    sys $7e0c, qlclr(kk) + 64

    x1 = qlx1(kk)
    y1 = qly1(kk)
    x2 = qlx2(kk)
    y2 = qly2(kk)

    'cursor 0,0:print chr$(27);"qx1,y1,x2,y2=",int(x1),int(y1),int(x2),int(y2)
    'cursor 0,1:print chr$(27);"qvx1,vy1,vx2,vy2=";qlvx1;qlvy1;qlvx2;qlvy2
    gosub draw_line

    'cursor x1/2,y1/2:print "+";
    'cursor x2/2,y2/2:print "+";
    'get key a$
  next k

  ' calc next line positions
  kk = qlidx  ' old qlidx
  qlidx = mod(qlidx + 1, 10)
  if qlcnt < 10 then qlcnt = qlcnt + 1

  qlx1(qlidx) = qlx1(kk) + qlvx1
  if qlx1(qlidx) >= 160 and qlvx1 > 0 then qlx1(qlidx)=159 : qlvx1 = -qlvx1
  if qlx1(qlidx) < 0 and qlvx1 < 0 then qlx1(qlidx)=0 : qlvx1 = -qlvx1

  qly1(qlidx) = qly1(kk) + qlvy1
  if qly1(qlidx) >= 100 and qlvy1 > 0 then qly1(qlidx)=99 : qlvy1 = -qlvy1
  if qly1(qlidx) < 0 and qlvy1 < 0 then qly1(qlidx)=0 : qlvy1 = -qlvy1

  qlx2(qlidx) = qlx2(kk) + qlvx2
  if qlx2(qlidx) >= 160 and qlvx2 > 0 then qlx2(qlidx)=159 : qlvx2 = -qlvx2
  if qlx2(qlidx) < 0 and qlvx2 < 0 then qlx2(qlidx)=0 : qlvx2 = -qlvx2

  qly2(qlidx) = qly2(kk) + qlvy2
  if qly2(qlidx) >= 100 and qlvy2 > 0 then qly2(qlidx)=99 : qlvy2 = -qlvy2
  if qly2(qlidx) < 0 and qlvy2 < 0 then qly2(qlidx)=0 : qlvy2 = -qlvy2

  qlcurclr = mod(qlcurclr + 1, 16)
  qlclr(qlidx) = qlcurclr

  goto qll_loop

  return


'-----------------
.draw_qix_triangles
'------------------
  ' init
  qlidx = 0

  qlcnt = 1
  t = 0
  pdist = 45
.tri_loop
  pdist = 22.5 - 22.5 * cos(t)
  centrex = 80 : centrey = 50

  pang = sqang - PI / 2
  qlx1(qlidx) = centrex + pdist * cos(pang)
  qly1(qlidx) = centrey + pdist * sin(pang)

  pang = pang + 2 * PI / 3
  qlx2(qlidx) = centrex + pdist * cos(pang)
  qly2(qlidx) = centrey + pdist * sin(pang)

  pang = pang + 2 * PI / 3
  qlx3(qlidx) = centrex + pdist * cos(pang)
  qly3(qlidx) = centrey + pdist * sin(pang)

  qlcurclr = mod(qlcurclr + 1, 16)
  qlclr(qlidx) = qlcurclr

  vsync 0
  print "{x93}";

  for k = 0 to qlcnt - 1
    ' kk = mod(qlidx + qlcnt-1 - k, 5)
    kk = mod(qlidx + k, 5)

    sys $7e0c, qlclr(kk) + 64

    x1 = qlx1(kk)
    y1 = qly1(kk)
    x2 = qlx2(kk)
    y2 = qly2(kk)

    'cursor 0,0:print chr$(27);"qx1,y1,x2,y2=",int(x1),int(y1),int(x2),int(y2)
    'cursor 0,1:print chr$(27);"qvx1,vy1,vx2,vy2=";qlvx1;qlvy1;qlvx2;qlvy2
    gosub draw_line

    x2 = qlx3(kk)
    y2 = qly3(kk)
    gosub draw_line

    x1 = qlx2(kk)
    y1 = qly2(kk)
    gosub draw_line

    'cursor x1/2,y1/2:print "+";
    'cursor x2/2,y2/2:print "+";
    'get key a$
  next k

  ' calc next line positions
  kk = qlidx  ' old qlidx
  qlidx = mod(qlidx + 1, 5)
  if qlcnt < 5 then qlcnt = qlcnt + 1

  sqang = sqang + .1
  if sqang > 2*PI then sqang = sqang - 2*PI

  qlcurclr = mod(qlcurclr + 1, 16)
  qlclr(qlidx) = qlcurclr

  t = t + .1
  if t > 2*PI then t = t - 2*PI

  goto tri_loop

  return


'---------------
.draw_many_cubes
'---------------
  cb_incb = 0
  for cb_inca = 0 to 1.9*PI/4 step PI/16
    ' print"{x93}"
    gosub draw_cube
    ' sleep .02
  next cb_inca

  cb_inca = 0
  for cb_incb = 0 to 1.9*PI/2 step PI/16
    ' print"{x93}"
    gosub draw_cube
    ' sleep .02
  next cb_incb

  return
  

'---------
.draw_cube
'---------
  pdist = 45
  cbidx = 0

  cb_angb = atn(1/sqr(2))
  for cb_anga = PI / 4 to 1.9 * PI step PI/2
    cbtmp = pdist * cos(cb_angb)
    pz = cbtmp * sin(cb_anga)
    py(cbidx) = pdist * sin(cb_angb)
    px(cbidx) = cbtmp * cos(cb_anga)
    gosub rotate_inca
    gosub rotate_incb
    px(cbidx) = centrex + px(cbidx) - pz * zfact / 4
    py(cbidx) = centrey + py(cbidx) + pz * zfact

    'print "px(";cbidx;")=";px(cbidx);", py(";cbidx;")=";py(cbidx)
    cbidx = cbidx + 1
  next cb_anga 

  plen = 4
  gosub draw_poly

  ' draw lines from poly
  cbidx = 0
  cb_angb = -atn(1/sqr(2))
  for cb_anga = PI / 4 to 1.9 * PI step PI/2
    x1 = px(cbidx)
    y1 = py(cbidx)

    cbtmp = pdist * cos(cb_angb)
    pz = cbtmp * sin(cb_anga)
    py(cbidx) = pdist * sin(cb_angb)
    px(cbidx) = cbtmp * cos(cb_anga)
    gosub rotate_inca
    gosub rotate_incb
    px(cbidx) = centrex + px(cbidx) - pz * zfact / 4
    py(cbidx) = centrey + py(cbidx) + pz * zfact

    x2 = px(cbidx)
    y2 = py(cbidx)

    gosub draw_line
    cbidx = cbidx + 1
  next cb_anga

  plen = 4
  gosub draw_poly

  return


'-----------
.rotate_inca
'-----------
  ' rotate along y-axis by inca
  diffx = px(cbidx)
  diffy = pz
  cbtmp = sqr(diffx*diffx + diffy*diffy)
  gosub atan2  ' returns angle
  angle = angle + cb_inca
  px(cbidx) = cbtmp * cos(angle)
  pz = cbtmp * sin(angle) 
  return


'-----------
.rotate_incb
'-----------
  ' rotate along z-axis by incb
  diffx = px(cbidx)
  diffy = py(cbidx)
  cbtmp = sqr(diffx*diffx + diffy*diffy)
  gosub atan2  ' returns angle
  angle = angle + cb_incb
  px(cbidx) = cbtmp * cos(angle)
  py(cbidx) = cbtmp * sin(angle) 
  return


'-----------------
.draw_many_squares
'-----------------
  for sqang = 0 to PI/2 step PI / 8
    gosub draw_square
  next sqang
  return


'-----------
.draw_square
'-----------
  pdist = 45

  pang = sqang - 3 * PI / 4
  px(0) = centrex + pdist * cos(pang)
  py(0) = centrey + pdist * sin(pang)

  pang = sqang - PI / 4
  px(1) = centrex + pdist * cos(pang)
  py(1) = centrey + pdist * sin(pang)

  pang = sqang + PI / 4
  px(2) = centrex + pdist * cos(pang)
  py(2) = centrey + pdist * sin(pang)

  pang = sqang + 3 * PI / 4
  px(3) = centrex + pdist * cos(pang)
  py(3) = centrey + pdist * sin(pang)

  plen = 4

  gosub draw_poly
  return


'---------
.draw_poly
'---------
  for pidx = 0 to plen-2
    x1 = px(pidx) : y1 = py(pidx)
    x2 = px(pidx+1) : y2 = py(pidx+1)
    ' print "x1=";x1;", y1=";y1;", x2=";x2;", y2=";y2
    ' get key a$
    gosub draw_line
  next pidx

  x1 = px(plen-1) : y1 = py(plen-1)
  x2 = px(0) : y2 = py(0)
  gosub draw_line

  return

'--------------------------
.draw_lines_from_centre_out
'--------------------------
  for ang = 0 to 2*PI step PI / 8

    x1 = 80
    y1 = 50
    x2 = int(80 + 30 * cos(ang))
    y2 = int(50 + 30 * sin(ang))

    ' cursor 0,20:print chr$(27);"qx1 =";x1;", y1 =";y1
    ' cursor 0,21:print chr$(27);"qx2 =";x2;", y2 =";y2
    ' get key a$
    ' if a$="d" then debug = 1: else debug = 0

    gosub draw_line
  next ang

  return


'---------
.draw_line
'---------
  sys $7e03
  x1 = mod(int(x1)+256,256)
  y1 = mod(int(y1)+256,256)
  x2 = mod(int(x2)+256,256)
  y2 = mod(int(y2)+256,256)
  sys $7e09, x1, y1, x2, y2
  return
  

'-----
.atan2
'-----
  if diffx = 0 then begin
    if diffy<0 then angle = - PI/2
    if diffy>0 then angle = PI/2
  bend:else begin
    tanval = diffy / diffx
    angle = atn(tanval)  ' this is range -90deg to 90deg
    if diffx<0 then begin
     if diffy<0 then angle = angle - PI:else angle = angle + PI
    bend
  bend
  return


'----------
.draw_pixel
'----------
  bank 0:sys $7e06, mod(cx+256, 256), mod(cy+256, 256), 5
  return

  ' pixel cropped?
  if cx<0 or cx>159 or cy<0 or cy>99 then return

  dx = int(cx/2) : dy = int(cy/2)
  mx = mod(int(cx),2) : my = mod(int(cy),2)

    ' cursor 0,16:print chr$(27);"qhx =";hx;", hy =";hy
    ' cursor 0,17:print chr$(27);"qmx =";mx;", my =";my

  cur_char = peek($40800 + dx + dy * 80)
  gosub read_on_pixels

  if mx = 0 and my = 0 then pix = pix or 1
  if mx = 1 and my = 0 then pix = pix or 2
  if mx = 0 and my = 1 then pix = pix or 4
  if mx = 1 and my = 1 then pix = pix or 8

  gosub set_on_pixels
  poke $40800 + dx + dy * 80, cur_char

  return


'--------------
.read_on_pixels
'--------------
  pix = 0 ' bitfields: tl = 1, tr = 2, bl = 4, br = 8
  if cur_char = PIX_TL then pix = 1:return
  if cur_char = PIX_TR then pix = 2:return
  if cur_char = PIX_BL then pix = 4:return
  if cur_char = PIX_BR then pix = 8:return
0{x8}
±{x8B}ð{x3}l?{x88}­V{x8B}Mß{x8B}P{xA}­W{x8B}Mà{x8B}P{x2}x{x60}{x18}­é{x8B}{x6D}á{x8B}{x8D}é{x8B}­ê{x8B}{x6D}â{x8B}{x8D}ê{x8B}{x18}­V{x8B}{x6D}ç{x8B}{x8D}V{x8B}­W{x8B}{x6D}è{x8B}{x8D}W{x8B}l?{x88}x{x60}{x8D}X{x8B}{x60}£{x9}­G{x8B}ê{x92}{x18}{x1B}­H{x8B}ê{x92}{x18}£{xC}­I{x8B}ê{x92}{x18}{x1B}­J{x8B}ê{x92}{x18}£{x7}­K{x8B}ê{x92}{x18}{x1B}­L{x8B}ê{x92}{x18}£{x4}­M{x8B}ê{x92}{x18}©{x4}{x8D}{x2}W©{xF}{xA}{xA}{xA}{xA}{x8D}°{x8B}{x8A})ðjjjj
°{x8B}{x60}­_{x8B}M­{x8B}{x90}r8­®{x8B}í¬{x8B}{x8D}±{x8B}­_{x8B}í­{x8B}{x8D}²{x8B}{x18}Û£{x18}Û£
í{x8B}ª½ð{x8B}zûê{x92}{x18}­X{x8B}ê{x92}{x1C}¦{x18}¤{x19}«î{x8B}{x60}­T{x8B}I{xA0}{x90}{x2}8{x60}­V{x8B}{x10}{x2}8{x60}­R{x8B}Ipð{x9}­T{x8B}Ip{x90}{xB}8{x60}­T{x8B}I{xA0}{x90}{x2}8{x60}­S{x8B}I2ð{x9}­V{x8B}I2{x90}{xB}8{x60}­V{x8B}I{x64}{x90}{x2}8{x60}{x18}{x60}{x18}­T{x8B}{x6A}{x8D}ÿ